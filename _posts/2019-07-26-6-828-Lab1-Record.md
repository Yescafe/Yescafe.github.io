---
layout: post
title: MIT 6.828 Startup/Lab1 记录
categories: [OS, MIT 6.828]
description: MIT 6.828 操作系统工程 准备工作/Lab1 记录
keywords: OS, 6.828
---
计划了一个多月了, 终于把这个项目给开了. MIT的6.828课程已是久仰大名了, 没想到有一天, 真的能够自己来过一遍这个课程, 来当一回MIT的"云学生".  

**该Lab1的工作环境为:** Ubuntu 18.04.2 LTS; gcc (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0; GNU Make 4.1;   

## 0. Tools and Tools Guide  
### Compiler Toolchain
在Lab开始之前, 我们需要检查编译器链的配置, 防止之后的编译报错.  
#### 检查objdump:  
```    
% objdump -i
```  
要求: 第二行显示elf32-i386.  
如我本地环境的输出结果为:  
```  
BFD header file version (GNU Binutils for Ubuntu) 2.30
elf64-x86-64
(header little endian, data little endian)
i386
elf32-i386
(header little endian, data little endian)
i386
elf32-iamcu
(header little endian, data little endian)
iamcu
elf32-x86-64
(header little endian, data little endian)
i386
a.out-i386-linux
(header little endian, data little endian)
i386
pei-i386
(header little endian, data little endian)
i386
pei-x86-64
(header little endian, data little endian)
i386
elf64-l1om
(header little endian, data little endian)
l1om
elf64-k1om
(header little endian, data little endian)
k1om
elf64-little
(header little endian, data little endian)
i386
l1om
k1om
iamcu
--More--
```  
考虑到我不是32位系统, 所以可能和官网描述有点误差, 暂时先不考虑这个问题, 如果有问题之后再想办法解决.  
#### 检查gcc环境:  
```   
% gcc -m32 -print-libgcc-file-name
```  
要求: 输出结果类似 /usr/lib/gcc/i486-linux-gnu/*version*/libgcc.a 或者 /usr/lib/gcc/x86_64-linux-gnu/*version*/32/libgcc.a 即可.  
如我本地环境的输出结果为:  
```  
/usr/lib/gcc/x86_64-linux-gnu/7/32/libgcc.a
```    
因为我的gcc版本是7.4, 所以*version*的位置是7.  
Ubuntu这个发行版还是比较舒服的, 很多库都是预置的, 即使没有使用apt装也是非常方便的. 在刚才的输出结果与上文不匹配时, 需要尝试安装下面这样东西:  
```  
% sudo apt-get install gcc-multilib
```    
然后需要安装两样工具:  
```  
% sudo apt-get install build-essential gdb
```  

### QEMU Emulator  
我们需要为接下来编写的操作系统提供一个虚拟运行环境, 这里使用的是qemu模拟器. 下面一段摘自[百度百科][1]:  
> **软件优点编辑**   
> 1. 默认支持多种架构。可以模拟 IA-32 (x86)个人电脑，AMD 64个人电脑，MIPS R4000, 升阳的SPARCsun3 与PowerPC(PReP 及 Power Macintosh)架构  
> 2. 可扩展，可自定义新的指令集  
> 3. 开源，可移植，仿真速度快  
> 4. 在支持硬件虚拟化的x86构架上可以使用KVM加速配合内核ksm大页面备份内存，速度稳定远超过VMware ESX  
> 5. 增加了模拟速度，某些程序甚至可以实时运行  
> 6. 可以在其他平台上运行Linux的程序  
> 7. 可以储存及还原运行状态(如运行中的程序)  
> 8. 可以虚拟网络卡   

总之看了半天, 我也不清楚为什么要用它, 反正官方叫用的, 那就用就对了.   

根据[みさか9982(cxy)同学所提供的资料][2], 我尝试手动编译qemu. 在补全了所需的环境后, make出现了编译错误, 导致了编译的无法进行, 而且并没有找到原因(可能是gcc的版本过高了?). 在Jo叔的建议下, 直接使用apt进行安装:  
```  
% sudo apt install qemu
```  

### Debugging tips
#### Reference - JOS makefile  
这边主要说明jos makefile的几种模式:  
```make qemu``` : 不知道到底是怎么弄的反正就是弄出来一个qemu的VGA console窗口, 并且映射一份输出到终端里. 关闭qemu需要在终端里键入C-c或者是C-a x.  
```make qemu-nox``` : 跟刚才唯一不同的就是, 这个没有VGA console窗口.  
```make qemu-gdb``` : 同```make qemu```, 并允许gdb接入.(暂时还不知道怎么用)  
```make qemu-nox-gdb``` : 同```make qemu-nox```, 并允许gdb接入.  
还有一些不知道怎么用.  

剩下的部分暂时不提了, 等用到的时候再说.   
直接参考官网文档: [https://pdos.csail.mit.edu/6.828/2018/labguide.html](https://pdos.csail.mit.edu/6.828/2018/labguide.html)

## Lab1: Booting a PC  
### Introducion   
这部分整了半天, 一觉醒来才发现, 哎哟woc, 原来我不是真的mit的学生.  
这部分是给mit学生提交作业评分用的, 略读的时候已经隐约感觉到了, 之后跟叔确认了一下, 确实是这样的.  
所以这个部分跳过.  

### Part I: PC Bootstrap
大多数专用名字我不是很喜欢翻译, 但是bootstrap这个词比较重要. 平时我们见的比较多的可能是它的简写形式, boot. 全写是bootstrap, 译为"引导".  

#### Getting Started with x86 assembly  
讲的汇编, 说是不需要通读手册, 而是在需要的时候回来查.   
AT&T的汇编, 在我看csapp第三章的时候已经略有了解, 但是水平还是很菜, 并且没有真正写过. 走一步看一步好了.    

#### Simulating the x86   
再学个单词, simulate, 模拟.   
cd到lab目录, 本地环境make的结果已经不在了, 大致上跟官网写的一样, 就把官网的抄来了:   
```  
+ as kern/entry.S
+ cc kern/entrypgdir.c
+ cc kern/init.c
+ cc kern/console.c
+ cc kern/monitor.c
+ cc kern/printf.c
+ cc kern/kdebug.c
+ cc lib/printfmt.c
+ cc lib/readline.c
+ cc lib/string.c
+ ld obj/kern/kernel
+ as boot/boot.S
+ cc -Os boot/main.c
+ ld boot/boot
boot block is 380 bytes (max 510)
+ mk obj/kern/kernel.img
```  
接着```make qemu```就能看到qemu的界面.  
此时我本地环境的终端输出结果如下:  
```   
***
*** Use Ctrl-a x to exit qemu
***
qemu-system-i386 -nographic -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log 
6828 decimal is XXX octal!
entering test_backtrace 5
entering test_backtrace 4
entering test_backtrace 3
entering test_backtrace 2
entering test_backtrace 1
entering test_backtrace 0
leaving test_backtrace 0
leaving test_backtrace 1
leaving test_backtrace 2
leaving test_backtrace 3
leaving test_backtrace 4
leaving test_backtrace 5
Welcome to the JOS kernel monitor!
Type 'help' for a list of commands.
K> 
```  
最原始的jos提供了两个指令, 一个是顾名思义(原文使用的词是obvious)的help, 另一个是一个内核监控器(kernel monitor).  
我们尝试先执行help, 再执行kerninfo, 再尝试使用C-a x退出.  
```  
K> help
help - Display this list of commands
kerninfo - Display information about the kernel
K> kerninfo
Special kernel symbols:
  _start                  0010000c (phys)
  entry  f010000c (virt)  0010000c (phys)
  etext  f01019e9 (virt)  001019e9 (phys)
  edata  f0113060 (virt)  00113060 (phys)
  end    f01136a0 (virt)  001136a0 (phys)
Kernel executable memory footprint: 78KB
K> QEMU: Terminated
```   
kerninfo输出的结果跟官网给的是有误差的, 但是估计应该是不影响后面的操作.  

#### The PC's Physical Address Space
这段就简单把官网的"图"搬过来了.  
```

+------------------+  <- 0xFFFFFFFF (4GB)
|      32-bit      |
|  memory mapped   |
|     devices      |
|                  |
/\/\/\/\/\/\/\/\/\/\

/\/\/\/\/\/\/\/\/\/\
|                  |
|      Unused      |
|                  |
+------------------+  <- depends on amount of RAM
|                  |
|                  |
| Extended Memory  |
|                  |
|                  |
+------------------+  <- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  <- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  <- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  <- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  |
+------------------+  <- 0x00000000
```
这里说到第一代PC, 处理器还是16位的Intel 8088, 并且只能为1MB的物理内存提供寻址(原文是were only capable of addressing 1MB of physical memory).  
最下面的低内存区(Low Memory)的640KB, 就是我们平时所说的RAM(random-access memory). 值得说明的是, 原文是这样写的:  
> The 640KB area marked "Low Memory" was the *only* random-access memory (RAM) that an early PC could use;   

这里的*only*被使用了着重处理, 强调RAM*只有*这640KB. 这里还有一些疑点, 之后再想办法解决.   
而且还听说更早一些的计算机的RAM甚至小到16KB, 这640KB已经算很多了.  

接下来从0x000A0000到0x000FFFFF的384KB是提供给硬件使用的, 这块是由BIOS保留的, 比如视频显示缓冲区(video display buffers, 这个buffers我是非常不想翻译的...),  还有保存在NVM中的固件(原文是and firmware held in non-volatile memory). NVM这东西我也是第一次简单, 并不是很了解, 所以有请[百度百科][3]:  
> Non-volatile memory，非易失存储器，具有非易失、按字节存取、存储密度高、低能耗、读写性能接近DRAM，但读写速度不对称，寿命有限。  

好了, 没用, 上[wikipedia][4]:   
> Non-volatile data storage can be categorized into electrically addressed systems (read-only memory) and mechanically addressed systems (hard disks, optical disc, magnetic tape, holographic memory, and such). Generally speaking, electrically addressed systems are expensive, have limited capacity, but are fast, whereas mechanically addressed systems are more cost effective per bit, but are slower.

*看上去这玩意儿有点像cache?*    
经过叔的更正, 这玩意儿其实就是普通的存储.    

接下来64KB的内存区域, 从0x000F0000到0x000FFFFF, 非常非常非常的重要, 这部分内存是提供给基本输入/输出系统(Basic Input/Output System, BIOS)使用的. 之前的机器的这段内存, 是真正的只读内存(原文是held in true read-only memory(ROM)), 但是现在的机器变成了可以更新的闪存(原文是updateable flash memory). BIOS的用处是执行一些系统基础的初始化(原文是is responsible for performing basic system initialization), 比如激活显示卡(activating the video card), 检查安装内存大小(checking the amount of memory installed). 这些初始化工序完成后, BIOS会从合适的区域((appropriate location)载入(load)系统, 比如软盘(floppy disk), 硬盘(hard disk), 光盘(CD-ROM), 或者是网络上(or the network), 然后把机器的控制权(control of machine)递交给(pass)操作系统.  
*真像父母把女儿养大, 最后连嫁妆一起嫁给女婿了...*

这里断开, 我先歇会儿.  

---

最终因特尔还是突破了1MB的障碍(原文是broke the one megabyte barrier), 80286和80386处理器诞生了, 他们分别支持高达16MB和4GB的物理地址空间, 也就是内存. 80386也就是之后的x86处理器了. 但是, pc框架师们还是为旧机器软件的兼容保留了低1MB物理内存空间的原始布局(原文是the PC architects nevertheless preserved the original layout for the low 1MB of physical address space in order to ensure backward compatibility with existing software, 这种长句我也不太会翻译, 参考了一下Google Translate的翻译).   
现代的pc给物理内存开了一个"洞(hole)", 地址是0x000A0000到0x00100000, 把RAM分割成了"低内存(low)"或者"可转换内存(conversional)"和"扩展内存(extended memory)"或者任何其他玩意儿(everything else). 另外, 32位机器的物理地址空间的最顶端, 在所有物理RAM之上, 现在通常是BIOS为pci设备保留的区域.  

现代x86处理器其实是支持超过4GB的物理内存的, 所以RAM可以被拓展到远不止0xFFFFFFFF. 这时候BIOS就必须开第二个*洞*, 位置在32位可寻址区域(32-bit addressable region)的顶部, 为这些32位设备提供空间用于映射. 这里我的理解可能是类似*二维指针*的东西?

因为设计缺陷(或者叫限制, design limitations), 我们这里的jos只使用首256MB的机器物理地址, 留出空间给32位设备用于映射.  

#### The ROM BIOS
这里开始, 我们就需要用gdb连接到qemu上了.  
开两个终端, cd到工程目录, 第一个执行make qemu-nox-gdb(也可以是make qemu-gdb, 我闲窗口太多了麻烦, 选择了nox的), 第二个执行make gdb.  
```
$ make qemu-nox-gdb
***
*** Now run 'make gdb'.
***
qemu-system-i386 -nographic -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log  -S
```

```
$ make gdb
gdb -n -x .gdbinit
GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word".
+ target remote localhost:26000
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
The target architecture is assumed to be i8086
[f000:fff0]    0xffff0:	ljmp   $0x3630,$0xf000e05b
0x0000fff0 in ?? ()
+ symbol-file obj/kern/kernel
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

(gdb)
```

```
[f000:fff0]    0xffff0:	ljmp   $0x3630,$0xf000e05b
```
话说这句好像是执行的第一条指令.  
简短一句汇编, 包含了太多的东西. ibm pc从0x000ffff0开始启动, 这个地址属于64KB ROM BIOS保留区域的最顶端; pc通过执行```CS = 0xf000```和```IP = 0xfff0```启动. 百度了一下这里的CS和IP是什么, CS是代码段寄存器, IP是指令指针寄存器(偏移地址). 但是这里bim pc和pc有啥区别?  
这第一个指令是一个jmp, 前面的l应该是前缀, 类似csapp里说的. 这个指令执行会跳到分段地址```CS = 0xf000```和```IP = 0xe05b```

然后就是qemu为什么要像这样启动. 这就是要归根到ibm初代机(原文是the original PC)使用的8088处理器上. 这台pc的BIOS的物理地址范围是固定在(原文是hard-wired, 硬线的, 或者说是天生的)0x000f0000-0x000fffff的范围内的, 这样的设计能确保BIOS总是能在启动或者~~重启(这里的重启是强制重启或者叫紧急重启)~~重置(经过下面实模式的百科引入后, 觉得这里还是应该翻译成重置比较好)之后获得机器的控制权. qemu模拟器自带它自己的BIOS, 这个BIOS放在了处理器模拟出来的物理地址空间中. 当处理器重置后, 虚拟处理器会进入real mode(实模式)并设置CS到0xf000, IP到0xfff0, 于是一切的开始就会从(CS:IP)段地址执行. 

接着来看段地址0xf000:0fff0是怎么换算物理地址.  
首先我们需要知道一点关于real mode的地址方式(addressing, 真的很神奇, 我翻译不出这个词, 后面就叫addressing吧).   
在real mode中, real mode就是pc从通电或者重置后最先进入的一个环境. 参考[百度百科][5]:  
> CPU复位（reset）或加电（power on）的时候以实模式启动，处理器以实模式工作。  

地址的转换公式是: $physical address=16*segment+offset$, 所以当pc将CS和IP分别设置到0xf000和0xfff0时, 换算成物理地址(原文是the physical address referenced is, reference这个词的意境翻译不出来, 直接意译)应该是:  
$$
16*0xf000+0xfff0\\
= 0xf0000+0xfff0\\
= 0xffff0\\
$$
显然哈, 这里的16把换算成十六进制就是10, 作用也就相当于十进制乘法中的10, 在被乘数的尾部加零, 也就是二进制左移4位.  
之前我们说到由BIOS的末端地址是0x100000(5个0, 1MB整的位置, 见上面那张从本家盗来的*图*), 正好是0xffff0的后面16 bytes的位置. 所以到这里, 我们也就不用惊讶为什么是跳到了BIOS尾部较前面一点的位置, 毕竟16 bytes也不能干啥.   

当BIOS运行的时候, 它创建了(原文是sets up, 意译)一个*中断描述器表*(interrupt descriptor table, 百度了一下翻译为"中断描述符表"), 并且需要初始化各种各样的设备, 比如之前提到的VGA Display. 这里可以在qemu窗口里看到一条"Starting SeaBIOS"消息.  
初始化PCI总线(PCI bus)和所有BIOS识别出来的(原文是定语从句the BIOS knows about)的重要设备, 它就开始从软盘/硬盘/光盘中搜索可启动设备(bootable device). 最终, 当它找到了可启动盘时, BIOS会从盘中读取*boot loader*并且把机器操纵权转交给它.  

*(这上面其实插入了一个Exercise 2, 我将放内容到后面)*

---

### Part 2: The Boot Loader




### 参考资料  
[本家]: [6.828 / Fall 2018](https://pdos.csail.mit.edu/6.828/2018/index.html)  
[1]: https://baike.baidu.com/item/QEMU   
[2]: https://www.cnblogs.com/gatsby123/p/9746193.html  
[3]: https://baike.baidu.com/item/NVM    
[4]: https://en.wikipedia.org/wiki/Non-volatile_memory    
[5]: https://baike.baidu.com/item/实模式  