---
layout: post
title: 6.828 Lab2 Memory Management 报告
categories: OS
description: 6.828 Lab2 的笔记和实验报告
keywords: OS, 6.828
---
# 正文
## 前言
在这个 lab 里, 我们将要为我们的操作系统加上内存管理(memory management)的代码.  
内存管理有两个组件:  
第一个是内核的物理内存分配器(physical memory allocator for kernel), 这个分配器以 4096 bytes 为字节操作, 也就是页(pages)宽. 我们的任务维护记录释放的物理页和分配的物理页, 以及进程之间的页共享数目的数据结构. 然后我们还需要编写分配释放内存的流程.  
第二个是虚拟内存(virtual memory), 将 kernel 和用户程序使用的物理内存地址映射到虚拟地址. The x86 hardware's memory management unit(MMU) 指令使用内存时时进行映射, 此时会用到一些页表(a set of page tables). 我们的任务是按照要求修改 JOS 去完成 MMU 页表的部署.  

### Getting started
先要把 lab2 的分支拉一下, 然后把 lab1 的 commit 合过来. 
```
$ git pull
Already up-to-date.
$ git checkout -b lab2 origin/lab2
Branch lab2 set up to track remote branch lab2 from origin.
Switched to a new branch 'lab2'
$ git merge lab1
Merge made by the 'recursive' strategy.
 kern/console.c |  2 +-
 kern/kdebug.c  |  8 ++++++--
 kern/monitor.c | 22 +++++++++++++++++++++-
 lib/printfmt.c |  7 +++----
 4 files changed, 31 insertions(+), 8 deletions(-)
```
最后在 `git branch` 确认一下分支, 这样就算是做完了. 

lab2 新加入了 5 个源文件:  
- `inc/memlayout.h`: 描述虚拟地址空间的布局. 
- `kern/pmap.h`: 上面这两个文件定义了 `PageInfo` 数据结构, 我们要使用它去跟踪空闲的物理内存页. 
- `kern/kclock.h`: 
- `kern/kclock.c`: 操作 PC 的电池供电时钟(battery-backed clock)和 CMOS RAM 硬件, 这里面有 BIOS 记录的物理内存量和其他的一些东西.  
- `kern/pmap.c`: 读取设备硬件, 计算物理内存量. 但是这段代码是需要我们自己写的, 应该就是最后的大作业了. 

### Lab Requirements
**完成所有常规 Exercise 和至少一个 Challenge.** 为 lab 结尾的 questions 写上简明的回答.  

## Part 1: Physical Page Management
JOS 使用 page granularity(页粒度)来管理物理内存, 以便它能使用 MMU 去映射和保护每一个 allocated 内存块.   
给我们的任务是完成物理页分配器的代码. 它会跟踪一个 `struct PageInfo` 对象的链表中的空闲页(对应到物理页). 我们需要在完成虚拟内存实现的剩余部分之前完成物理页分配器.   
完成 Exercise 1.  
*说真的, 好难, 真的好难.* 

## Part 2: Virtual Memory



# Exercise
## Exercise 1
> **Exercise 1.** In the file `kern/pmap.c`, you must implement code for the following functions (probably in the order given).
> 
> `boot_alloc()`  
> `mem_init()` (only up to the call to `check_page_free_list(1)`)  
> `page_init()`  
> `page_alloc()`  
> `page_free()`  
> 
> `check_page_free_list()` and `check_page_alloc()` test your physical page allocator. You should boot JOS and see whether `check_page_alloc()` reports success. Fix your code so that it passes. You may find it helpful to add your own `assert()`s to verify that your assumptions are correct.

按先后次序实现这些函数.   
`boot_alloc()`:  
```c
// This simple physical memory allocator is used only while JOS is setting
// up its virtual memory system.  page_alloc() is the real allocator.
//
// If n>0, allocates enough pages of contiguous physical memory to hold 'n'
// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.
//
// If n==0, returns the address of the next free page without allocating
// anything.
//
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.

	// If n>0, allocates enough pages of contiguous physical memory to hold 'n'
	// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.
	if (n > 0) {
		char *new_nextfree = ROUNDUP((char *) nextfree + n, PGSIZE);
		// If alloc failed
		if (new_nextfree < nextfree)
			panic("Alloc failed.");
		// If we're out of memory, boot_alloc should panic.
        // 这里的 `PADDR` 参考了孟佬的文章
		if (PADDR(new_nextfree) > 0x40000000)
			panic("Out of memory.");
		result = nextfree;
		nextfree = new_nextfree;
		return (void *) result;
	}
	// If n==0, returns the address of the next free page without allocating
	// anything.
	else if (n == 0) {
		return (void *) nextfree;
	}

	return NULL;
}
```  
部分代码参考了孟佬的文章[$^1$](#ref1).  
`mem_init()`:    
```c
// Set up a two-level page table:
//    kern_pgdir is its linear (virtual) address of the root
//
// This function only sets up the kernel part of the address space
// (ie. addresses >= UTOP).  The user part of the address space
// will be set up later.
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
mem_init(void)
{
	uint32_t cr0;
	size_t n;

	// Find out how much memory the machine has (npages & npages_basemem).
	i386_detect_memory();

	// Remove this line when you're ready to test this function.
    // 完成了这里注释掉
	// panic("mem_init: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address UVPT.
	// (For now, you don't have understand the greater purpose of the
	// following line.)

	// Permissions: kernel R, user R
	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

	//////////////////////////////////////////////////////////////////////
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
	// Your code goes here:
    // npages 是一个全局变量, 由 `i386_detect_memory()` 确定. 
	pages = (struct PageInfo *)boot_alloc(sizeof(struct PageInfo) * npages);
	memset(pages, 0, sizeof(struct PageInfo) * npages);

	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region
	// or page_insert
	page_init();

	check_page_free_list(1);
	check_page_alloc();
	check_page();

	//////////////////////////////////////////////////////////////////////
	// Now we set up virtual memory

	//////////////////////////////////////////////////////////////////////
	// Map 'pages' read-only by the user at linear address UPAGES
	// Permissions:
	//    - the new image at UPAGES -- kernel R, user R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:

	//////////////////////////////////////////////////////////////////////
	// Use the physical memory that 'bootstack' refers to as the kernel
	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
	// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
	// to be the kernel stack, but break this into two pieces:
	//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:

	//////////////////////////////////////////////////////////////////////
	// Map all of physical memory at KERNBASE.
	// Ie.  the VA range [KERNBASE, 2^32) should map to
	//      the PA range [0, 2^32 - KERNBASE)
	// We might not have 2^32 - KERNBASE bytes of physical memory, but
	// we just set up the mapping anyway.
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	// Check that the initial page directory has been set up correctly.
	check_kern_pgdir();

	// Switch from the minimal entry page directory to the full kern_pgdir
	// page table we just created.	Our instruction pointer should be
	// somewhere between KERNBASE and KERNBASE+4MB right now, which is
	// mapped the same way by both page tables.
	//
	// If the machine reboots at this point, you've probably set up your
	// kern_pgdir wrong.
	lcr3(PADDR(kern_pgdir));

	check_page_free_list(0);

	// entry.S set the really important flags in cr0 (including enabling
	// paging).  Here we configure the rest of the flags that we care about.
	cr0 = rcr0();
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
	cr0 &= ~(CR0_TS|CR0_EM);
	lcr0(cr0);

	// Some more checks, only possible after kern_pgdir is installed.
	check_page_installed_pgdir();
}
```
`page_init()`:  
```c
// --------------------------------------------------------------
// Tracking of physical pages.
// The 'pages' array has one 'struct PageInfo' entry per physical page.
// Pages are reference counted, and free pages are kept on a linked list.
// --------------------------------------------------------------

//
// Initialize page structure and memory free list.
// After this is done, NEVER use boot_alloc again.  ONLY use the page
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
	// The example code here marks all physical pages as free.
	// However this is not truly the case.  What memory is free?
	//  1) Mark physical page 0 as in use.
	//     This way we preserve the real-mode IDT and BIOS structures
	//     in case we ever need them.  (Currently we don't, but...)
	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
	//     is free.
	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
	//     never be allocated.
	//  4) Then extended memory [EXTPHYSMEM, ...).
	//     Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for
	//     page tables and other data structures?
	//
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!
	/*
	struct PageInfo {
		// Next page on the free list.
		struct PageInfo *pp_link;

		// pp_ref is the count of pointers (usually in page table entries)
		// to this page, for pages allocated using page_alloc.
		// Pages allocated at boot time using pmap.c's
		// boot_alloc do not have valid reference count fields.

		uint16_t pp_ref;
	};
	*/

	size_t i;
	size_t size;

	// 1) Mark physical page 0 as in use.
	pages[0].pp_ref = 1;

	// 2) The rest of base memory. 
	// [PGSIZE, npages_basemem * PGSIZE)
	for (i = 1; i < npages_basemem; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}

	// 3) The IO hole.
	// [IOPHYSMEM, EXTPHYSMEM)
	for (; i < EXTPHYSMEM / PGSIZE; i++) {
		pages[i].pp_ref = 1;
	}

	// 4) Extended memory.
	// [EXTPHYSMEM, ...)
	size_t first_free_page_idx = PADDR(boot_alloc(0)) / PGSIZE;
	for (; i < first_free_page_idx; i++) {
		pages[i].pp_ref = 1;
	}

	for (; i < npages; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
}
```
部分参考了网友完成的 6.828 JOS 代码[$^2$](#ref2).  
`page_alloc()`:  
```c
struct PageInfo *
page_alloc(int alloc_flags)
{
	// Fill this function in
	struct PageInfo *alloc_page;
	if (page_free_list == NULL) {
		return NULL;
	}
	alloc_page = page_free_list;
	page_free_list = alloc_page->pp_link;
	alloc_page->pp_link = NULL;

	if (alloc_flags & ALLOC_ZERO) {
		memset(page2kva(alloc_page), 0, PGSIZE);
	}
	return alloc_page;
}
```  
`page2kva()` 函数可以将 page 的地址转换为 kernel virtual address. 这段是我蠢了, 没看其他的人的文章真的没想到.  
`page_free()`:  
```c
void
page_free(struct PageInfo *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if (pp->pp_ref != 0) {
		panic("pp->pp_ref is nonzero.");
		return ;
	}
	if (pp->pp_link != NULL) {
		panic("pp->pp_link is not NULL.");
		return ;
	}
	pp->pp_link = page_free_list;
	page_free_list = pp;
}
```
这五个函数写起来其实不是很难, 只是用到了一些宏呀函数呀全局变量呀不是特别熟悉, 参考了一些资料后完成后再来看代码着实是非常简单, 所谓的链表数据结构也就只是最简单的 push 和 pop 操作.   
中间出了一些没有转换成物理地址的问题, 都用 `assert(0)` 断点(至今还是不习惯用 gdb 调试)处理好了.  
注意, 这里只需要过 `check_page_free_list()` 和 `check_page_alloc()` 就行了, `check_page()` 暂时过不了.  


## Exercise 2

# 引用
1. <span id="ref1">https://zhuanlan.zhihu.com/p/41871340</span>
2. <span id="ref2">https://github.com/SmallPond/MIT6.828_OS/blob/master/lab/kern/pmap.c</span>