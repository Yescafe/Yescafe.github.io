---
layout: post
title: 6.828 Lab1 Booting a PC 报告
categories: OS
description: 6.828 Lab1 笔记
keywords: OS, 6.828
---
# 正文
## 前言
### 工具链
用 Ubuntu 比较方便:  
```bash
sudo apt install -y gcc objdump
sudo apt install -y build-essential gdb
sudo apt install -y gcc-multilib
sudo apt install -y qemu
```

### 软件配置
首先是 git 的部署和基本用法.  
然后是整个项目的 Makefile. 使用 `make handin` 可以提交, 但是我不是 MIT 的学生; `make grade` 可以测成绩.   

### 系统环境
本来是在装有 Ubuntu 18.04 的母机上跑的, 因为系统位数原因换成了 Windows 10 下跑 Ubuntu 16.04 32 位的虚拟机, 使用 ssh 连接.   

## Part 1: PC Bootstrap
### x86 汇编
汇编已经在上上一篇博文里完成了. 不过因为 828 全程用到 gcc, 所以汇编自然是 AT&T 风格的, 区别于 NASM.  

### 模拟 x86
```bash
make
```
输出:  
```
+ as kern/entry.S
+ cc kern/entrypgdir.c
+ cc kern/init.c
+ cc kern/console.c
+ cc kern/monitor.c
+ cc kern/printf.c
+ cc kern/kdebug.c
+ cc lib/printfmt.c
+ cc lib/readline.c
+ cc lib/string.c
+ ld obj/kern/kernel
ld: warning: section `.bss' type changed to PROGBITS
+ as boot/boot.S
+ cc -Os boot/main.c
+ ld boot/boot
boot block is 390 bytes (max 510)
+ mk obj/kern/kernel.img
```
bss 段报了个警告, 但是问题不大.  

用 `make qemu` 或者 `make qemu-nox` 可以放 QEMU 里面跑.  
系统自带两个指令, `help` 和 `kerninfo`. `C-A,X` 可以退出 QEMU.  

### PC 的物理地址空间
```
+------------------+  <- 0xFFFFFFFF (4GB)
|      32-bit      |
|  memory mapped   |
|     devices      |
|                  |
/\/\/\/\/\/\/\/\/\/\

/\/\/\/\/\/\/\/\/\/\
|                  |
|      Unused      |
|                  |
+------------------+  <- depends on amount of RAM
|                  |
|                  |
| Extended Memory  |
|                  |
|                  |
+------------------+  <- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  <- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  <- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  <- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  |
+------------------+  <- 0x00000000
```
注意, JOS 被限制只用 PC 物理地址的前 256MB.  

### The ROM BIOS
在第一个终端里执行 `make qemu-gdb` 或者 `make qemu-nox-gdb`, QEMU 会停在处理器执行第一个指令之前. 接着在第二个终端里输入 `make gdb` 可以对 QEMU 里的系统进行调试.  

接着, 可以跟踪到第一条指令是:  
```asm
[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b
```
这里 CS = 0xf000, IP = 0xe05b.  

BIOS运行, 将会部署中断描述符表, 并且初始化一些设备.  
当初始化完成 PCI 总线和一些重要设备后, 它开始在存储盘中搜索引导设备(bootable device), 以启动boot loader.

## Part 2: The Boot Loader
PC 的软盘硬盘会被分成 512 bytes 的扇区(sectors), 扇区是盘的最小传输粒度(minimum transfer granularity). 一个可引导盘的第一个扇区被叫做引导扇区(boot sector), 里面有 boot loader 的代码. 如果 BIOS 找到了可引导盘, 它会把 boot loader 读进物理内存的 0x7c00~0x7dff (512 bytes), 然后使用 `jmp` 跳到 `0000:7c00`.  
CD-ROMS 的一个扇区有 2048 bytes, boot loader 也会随之变大, BIOS 读取的内容也要随之变大. 详见 [*"El Torito" Bootable CD-ROM Format Specification*](https://pdos.csail.mit.edu/6.828/2018/readings/boot-cdrom.pdf). 略.  

接着是两个源代码, `boot/boot.S` 和 `boot/main.c`, 根据叔的文章, 这两个代码必须完全弄懂.  
boot/boot.S  
```asm
#include <inc/mmu.h>             # Memory Management Unit 内存管理单元

# Start the CPU: switch to 32-bit protected mode, jump into C.
# The BIOS loads this code from the first sector of the hard disk into
# memory at physical address 0x7c00 and starts executing in real mode
# with %cs=0 %ip=7c00.
# 启动 CPU, 切换到 32 位保护模式, 然后跳转到 C. 
# 这段代码就是 boot loader, BIOS 会从硬盘的第一个扇区读取它们到物理内存的 0x7c00, 
# 然后在实模式中从 0000:7c00 开始执行. 

.set PROT_MODE_CSEG, 0x8         # 内核的 CS 选择器
.set PROT_MODE_DSEG, 0x10        # 内核的 DS 选择器
.set CR0_PE_ON,      0x1         # 保护模式启动标志, CR0, Exercise 2 中有提到

.globl start
start:
  .code16                     # Assemble for 16-bit mode
  cli                         # Disable interrupts
  cld                         # String operations increment. DF = 0, 增方向

  # Set up the important data segment registers (DS, ES, SS).
  xorw    %ax,%ax             # ax = 0
  movw    %ax,%ds             # ds = 0
  movw    %ax,%es             # es = 0
  movw    %ax,%ss             # ss = 0

  # Enable A20:
  #   For backwards compatibility with the earliest PCs, physical
  #   address line 20 is tied low, so that addresses higher than
  #   1MB wrap around to zero by default.  This code undoes this.
  # 开启 A20:
  #   同样在 Exercise 2 中有提到过.
  #   物理地址线 20 开启, 这样可以保证良好的向后兼容性.
  #
# seta20.1 是向键盘控制器的 0x64 端口发送 0x61 命令, 这个命令的意思是要向键盘控制器的 P2 写入数据.
seta20.1:
  inb     $0x64,%al               # Wait for not busy
  # if al & 0x2 == 0, ZF 置位.
  # 相当于 bit2 为 0 时, ZF 置位.
  testb   $0x2,%al
  # if ZF == 0, jmp.
  # 相当于 bit2 为 0 时, 跳转, 否则循环直到 bit2 为空位.
  # 0x64 端口是 KB controller read status, 键盘控制器读状态寄存器.
  jnz     seta20.1

  # 向 0x64 端口写入 0xd1.
  # 0x60 接口是 PS/2 硬件接口或者 PS/2 控制器本身读/写数据.
  # 0x64 是状态寄存器.
  # 将 0xd1 写入 0x64 端口, 是设置这个状态寄存器, 
  # 使可以通过 0x60 端口写入数据而控制 PS/2 的状态.
  movb    $0xd1,%al               # 0xd1 -> port 0x64
  outb    %al,$0x64

seta20.2:
  # 同上. 检测缓冲区是否有空位, 没有则等待.
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.2

  # 将 0xdf 写入 0x60, 开启 A20 地址总线.
  # 但是 Exercise 2 中出现的是将 0x60 的 bit1 置为 1.
  # 原因不明.
  movb    $0xdf,%al               # 0xdf -> port 0x60
  outb    %al,$0x60

  # Switch from real to protected mode, using a bootstrap GDT
  # and segment translation that makes virtual addresses 
  # identical to their physical addresses, so that the 
  # effective memory map does not change during the switch.
  # 从实模式切换到保护模式的准备工作.
  # 将 gdtdesc(在代码最后) 加载到 GDTR 中.
  # GDT 是全局描述符表, GDTR 是全局描述符表寄存器.
  # 想要在保护模式下对内存进行寻址就先要有 GDT, GDT 表里每一项叫做段描述符, 
  # 用来记录每个内存分段的一些属性信息, 每个段描述符占8字节.
  # CPU 使用 GDTR 寄存器来保存我们 GDT 在内存中的位置和 GDT 的长度.
  # 所以才有了 gdtdesc 里面的内容.
  lgdt    gdtdesc
  # 将 CR0 的 bit0 置 1, 准备进入保护模式.
  movl    %cr0, %eax
  orl     $CR0_PE_ON, %eax
  movl    %eax, %cr0

  # Jump to next instruction, but in 32-bit code segment.
  # Switches processor into 32-bit mode.
  # 长跳转到 protcseg, $PROT_MODE_CSEG 是前面设置的 CS 宏(?)
  ljmp    $PROT_MODE_CSEG, $protcseg

  .code32                     # Assemble for 32-bit mode
protcseg:
  # Set up the protected-mode data segment registers
  # 部署保护模式数据段寄存器, 跟 Exercise 2 中的类似.
  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector
  movw    %ax, %ds                # -> DS: Data Segment
  movw    %ax, %es                # -> ES: Extra Segment
  movw    %ax, %fs                # -> FS
  movw    %ax, %gs                # -> GS
  movw    %ax, %ss                # -> SS: Stack Segment

  # Set up the stack pointer and call into C.
  # 将栈区设置在 $start 处
  # 因为栈的工作模式是地址减为增方向, 所以不会影响代码部分.
  movl    $start, %esp
  # 调用 C 接口 bootmain.
  call bootmain

  # If bootmain returns (it shouldn't), loop.
  # 死循环.
spin:
  jmp spin

# Bootstrap GDT
# 设置 4 字节对齐
.p2align 2                                # force 4 byte alignment
# 初始化 gtd 表
gdt:
  SEG_NULL                              # null seg
  SEG(STA_X|STA_R, 0x0, 0xffffffff)     # code seg
  SEG(STA_W, 0x0, 0xffffffff)           # data seg

gdtdesc:
  .word   0x17                            # sizeof(gdt) - 1
  .long   gdt                             # address gdt
```
boot/main.c  
```c
#include <inc/x86.h>
#include <inc/elf.h>

/**********************************************************************
 * This a dirt simple boot loader, whose sole job is to boot
 * an ELF kernel image from the first IDE hard disk.
 * 这是一个简单的 boot loader, 作用仅仅是从 IDE 硬盘引导 ELF 内核镜像.
 *
 * DISK LAYOUT
 *  * This program(boot.S and main.c) is the bootloader.  It should
 *    be stored in the first sector of the disk.
 *  * 注意 boot.S 和 main.c 一起才是 boot loader. 需要被存储在盘的第一扇区.
 *
 *  * The 2nd sector onward holds the kernel image.
 *  * 第二扇区开始存放内核镜像.
 *
 *  * The kernel image must be in ELF format.
 *  * 内核镜像必须是 ELF 格式.
 *
 * BOOT UP STEPS
 *  * when the CPU boots it loads the BIOS into memory and executes it
 *
 *  * the BIOS intializes devices, sets of the interrupt routines, and 
 *    reads the first sector of the boot device(e.g., hard-drive)
 *    into memory and jumps to it.
 *  * BIOS 初始化设备和一些中断程式, 然后从引导设备读入第一个扇区到内存后跳转.
 *
 *  * Assuming this boot loader is stored in the first sector of the
 *    hard-drive, this code takes over...
 *
 *  * control starts in boot.S -- which sets up protected mode,
 *    and a stack so C code then run, then calls bootmain()
 *  * 执行 boot.S, 用来部署保护模式和能够让 C 代码运行的栈, 然后调用 C 接口 `bootmain()`.
 *
 *  * bootmain() in this file takes over, reads in the kernel and jumps to it.
 **********************************************************************/

/**********************************************************************
这段注释直接白嫖自叔的文章[2].
// The definition of struct Elf.
struct Elf {
 	    uint32_t e_magic;               // must equal ELF_MAGIC. 保存了 4 个 char, "\0x7FELF", 用来校验是否是一个 Elf 结构体
 	    uint8_t  e_elf[12];             // 应该是关于一些平台相关的设置, 关系到如何译码和解释文件内容存  疑. 
 	    uint16_t e_type;                // 该文件的类型
 	    uint16_t e_machine;             // 该文件需要的体系结构
 	    uint32_t e_version;             // 文件的版本
 	    uint32_t e_entry;               // 程序的入口地址
 	    uint32_t e_phoff;               // 表示 Program header table 在文件中的偏移量(以字节计算)
 	    uint32_t e_shoff;               // 表示 Section header table 在文件中的偏移量(以字节计算)
 	    uint32_t e_flags;               // 对 IA32 而言, 此项为 0. 
 	    uint16_t e_ehsize;              // 表示 ELF header 大小
 	    uint16_t e_phentsize;           // 表示 Program header table 中每一个条目的大小
 	    uint16_t e_phnum;               // 表示 Program header table 中有多少个条目
 	    uint16_t e_shentsize;           // 表示 Section header table 中每一个条目的大小
 	    uint16_t e_shnum;               // 表示 Section header table 中有多少个条目
 	    uint16_t e_shstrndx;            // 表示包含节名称的字符串是第几个节
};

// The definition of struct Proghdr.
struct Proghdr {
    uint32_t p_type;                  // 当前 program 的段类型
		uint32_t p_offset;                // 段的第一个字节在文件中的偏移
		uint32_t p_va;                    // 段的第一个字节在文件中的虚拟地址
		uint32_t p_pa;                    // 段的第一个字节在文件中的物理地址, 在物理内存定位相关的系统中使用
		uint32_t p_filesz;                // 段在文件中的长度
		uint32_t p_memsz;                 // 段在内存中的长度
		uint32_t p_flags;                 // 与段相关的标识位
		uint32_t p_align;                 // 根据此项来确定段在文件以及内存中如何对齐
};
 **********************************************************************/

// 扇区大小
#define SECTSIZE        512
// 一个 ELF 表存在 0x10000.
#define ELFHDR          ((struct Elf *) 0x10000) // scratch space

void readsect(void*, uint32_t);
void readseg(uint32_t, uint32_t, uint32_t);

void
bootmain(void)
{
        // program header table, 第一个是指向表中 program header 的指针.
        // eph 是 end of program header.
        struct Proghdr *ph, *eph;

        // read 1st page off disk
        // 读取从 0 开始的 8 个扇区放入 ELFHDR 位置.
        readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);

        // is this a valid ELF?
        // 校验它是不是 Elf 结构体. 
        if (ELFHDR->e_magic != ELF_MAGIC)
                goto bad;

        // load each program segment (ignores ph flags)
        // 读取 program header table, 地址是 ELFHDR + pht offset
        ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);
        // end of program header, program header table 的最后一个条目的下一个位置. 
        eph = ph + ELFHDR->e_phnum;
        // 将 program headers 读入内存
        for (; ph < eph; ph++)
                // p_pa is the load address of this segment (as well
                // as the physical address)
                // 从 offset 读 memsz 长度的数据到 pa 里.
                readseg(ph->p_pa, ph->p_memsz, ph->p_offset);

        // call the entry point from the ELF header
        // note: does not return!
        // 运行程序入口
        ((void (*)(void)) (ELFHDR->e_entry))();

bad:
        // 0x8A00 写入 0x8A00 端口, 0x8A00 写入 0x8E00 端口
        // 开启 IO Debug
        // 可以在 bocks 的调试器中看到状态
        outw(0x8A00, 0x8A00);
        outw(0x8A00, 0x8E00);
        while (1)
                /* do nothing */;
}

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
// 从内核的 offset 读取 count 个字节进物理地址 pa
void
readseg(uint32_t pa, uint32_t count, uint32_t offset)
{
        uint32_t end_pa;

        end_pa = pa + count;

        // round down to sector boundary
        // 抹掉低位的数字, 锁定到扇区边界.
        // 比如这里 SECTSIZE 为 512, 减一求反后, 二进制低 9 位均为 0, 高位全为 1.
        // 原地做与运算可以将低 9 位抹成 0.
        pa &= ~(SECTSIZE - 1);

        // translate from bytes to sectors, and kernel starts at sector 1
        // 将 offset 的单位由字节计算成扇区. 内核是从扇区 1 开始的, 所以再加 1.
        offset = (offset / SECTSIZE) + 1;

        // If this is too slow, we could read lots of sectors at a time.
        // We'd write more to memory than asked, but it doesn't matter --
        // we load in increasing order.
        while (pa < end_pa) {
                // Since we haven't enabled paging yet and we're using
                // an identity segment mapping (see boot.S), we can
                // use physical addresses directly.  This won't be the
                // case once JOS enables the MMU.
                // 从编号为 offset 的扇区读取数据进文件的物理地址
                readsect((uint8_t*) pa, offset);
                pa += SECTSIZE;
                offset++;
        }
}

void
waitdisk(void)
{
        // wait for disk reaady
        // 一直从 0x1f7 读取数据, 直至它空闲.
        // 0x40 这个位为 1 时, 表示空闲.
        while ((inb(0x1F7) & 0xC0) != 0x40)
                /* do nothing */;
}

// 读入一个扇区
void
readsect(void *dst, uint32_t offset)
{
        // wait for disk to be ready
        waitdisk();

        // outb(port, data);
        // 向端口输出数据
        outb(0x1F2, 1);         // count = 1
        // offset 太长了, 所以分段
        outb(0x1F3, offset);
        outb(0x1F4, offset >> 8);
        outb(0x1F5, offset >> 16);
        outb(0x1F6, (offset >> 24) | 0xE0);
        outb(0x1F7, 0x20);      // cmd 0x20 - read sectors

        // wait for disk to be ready
        waitdisk();

        // read a sector
        // 0x1F0 是硬盘接口的数据端口, 是一个 16 位端口.
        // 一旦硬盘空闲且准备就绪, 就可以连续从这个端口写入或读取数据.
        // 第三个参数是双字, 所以要除以 4.
        insl(0x1F0, dst, SECTSIZE/4);
}
```

原文在 Exercise3 结束之后, 提了几个问题:  
- Q: At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?  
- Q: What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?
- Q: Where is the first instruction of the kernel?
- Q: How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?  

老实说这些问题我都回答不上来. 先放着. 既然是要求的一定会补上.   

### Loading the Kernel
恩, 一上来就是 Exercise 4.  
ELF 是 Executable and Linkable Format 的缩写. 编译器先将 C 源文件(`*.c`)编译成目标文件(`*.o`), 目标文件包含汇编编码成的硬件可执行的二进制格式. Full information about this format is available in the [ELF specification](https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf) on our reference page. ELF 很复杂不是这个课程的部分, 所以直接参考 [Wikipedia Page](http://en.wikipedia.org/wiki/Executable_and_Linkable_Format).  

一个 ELF binary 有定长的 ELF header, C 定义的这个头为 `inc/elf.h`. 我们需要关注的部分是:  
- `.text`, 程序执行指令.
- `.rodata`, read-only 数据, 比如 ASCII 常量.
- `.data`, 数据段持有程序的初始化数据, 比如全局变量声明的 `int x = 5;`.

当链接器计算程序内存布局时, 会为未初始化全局变量(uninitialized global variables)保留空间, 这段是紧跟在 `.data` 之后的 `.bss` 段. C 会将未初始化的 `.bss` 段初始化为 0.  
接着他让我们自己使用 objdump 工具检查程序的段, 使用 `-h` 参数. 在 `.text` 段中, VMA 表示 link address, LMA 表示 load address. 比如我们使用原文中举例的 boot loader 文件:  
```
ivan@ubuntu:~/6.828/jos$ objdump -h obj/boot/boot.out 

obj/boot/boot.out:     file format elf32-i386

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000186  00007c00  00007c00  00000074  2**2
                  CONTENTS, ALLOC, LOAD, CODE
  1 .eh_frame     000000a8  00007d88  00007d88  000001fc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .stab         00000720  00000000  00000000  000002a4  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      0000088f  00000000  00000000  000009c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .comment      00000035  00000000  00000000  00001253  2**0
                  CONTENTS, READONLY
```
`-x` 参数可以输出程序头信息和链接器使用的符号表.  
```
ivan@ubuntu:~/6.828/jos$ objdump -x obj/kern/kernel

obj/kern/kernel:     file format elf32-i386
obj/kern/kernel
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0010000c

Program Header:
    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12
         filesz 0x00007120 memsz 0x00007120 flags r-x
    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12
         filesz 0x0000a948 memsz 0x0000a948 flags rw-
   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4
         filesz 0x00000000 memsz 0x00000000 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001871  f0100000  00100000  00001000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000714  f0101880  00101880  00002880  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .stab         000038d1  f0101f94  00101f94  00002f94  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .stabstr      000018bb  f0105865  00105865  00006865  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .data         0000a300  f0108000  00108000  00009000  2**12
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000648  f0112300  00112300  00013300  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  6 .comment      00000035  00000000  00000000  00013948  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
f0100000 l    d  .text	00000000 .text
f0101880 l    d  .rodata	00000000 .rodata
f0101f94 l    d  .stab	00000000 .stab
f0105865 l    d  .stabstr	00000000 .stabstr
f0108000 l    d  .data	00000000 .data
f0112300 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    df *ABS*	00000000 obj/kern/entry.o
f010002f l       .text	00000000 relocated
f010003e l       .text	00000000 spin
00000000 l    df *ABS*	00000000 entrypgdir.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 console.c
f0100177 l     F .text	0000001f serial_proc_data
f0100196 l     F .text	00000043 cons_intr
f0112320 l     O .bss	00000208 cons
f01001d9 l     F .text	00000119 kbd_proc_data
f0112300 l     O .bss	00000004 shift.1407
f0101a60 l     O .rodata	00000100 shiftcode
f0101960 l     O .rodata	00000100 togglecode
f0101940 l     O .rodata	00000010 charcode
f01002f2 l     F .text	000001e9 cons_putc
f0112528 l     O .bss	00000002 crt_pos
f011252c l     O .bss	00000004 crt_buf
f0112530 l     O .bss	00000004 addr_6845
f0112534 l     O .bss	00000001 serial_exists
f0112200 l     O .data	00000100 normalmap
f0112100 l     O .data	00000100 shiftmap
f0112000 l     O .data	00000100 ctlmap
00000000 l    df *ABS*	00000000 monitor.c
f0101d44 l     O .rodata	00000018 commands
00000000 l    df *ABS*	00000000 printf.c
f01008bf l     F .text	00000013 putch
00000000 l    df *ABS*	00000000 kdebug.c
f010090c l     F .text	000000f6 stab_binsearch
00000000 l    df *ABS*	00000000 printfmt.c
f0100bd3 l     F .text	000000af printnum
f0100c82 l     F .text	0000001d sprintputch
f0101f68 l     O .rodata	0000001c error_string
00000000 l    df *ABS*	00000000 readline.c
f0112540 l     O .bss	00000400 buf
00000000 l    df *ABS*	00000000 string.c
f010000c g       .text	00000000 entry
f010129c g     F .text	00000020 strcpy
f01004f7 g     F .text	00000012 kbd_intr
f010076e g     F .text	0000000a mon_backtrace
f01000e6 g     F .text	00000057 _panic
f0100094 g     F .text	00000052 i386_init
f010142e g     F .text	00000068 memmove
f0101170 g     F .text	0000001a snprintf
f0100cbc g     F .text	00000466 vprintfmt
f0100509 g     F .text	0000004a cons_getc
f01008f8 g     F .text	00000014 cprintf
f0101496 g     F .text	00000013 memcpy
f010118a g     F .text	000000d9 readline
f0111000 g     O .data	00001000 entry_pgtable
f0100040 g     F .text	00000054 test_backtrace
f0101122 g     F .text	0000004e vsnprintf
f0112300 g       .bss	00000000 edata
f0100553 g     F .text	00000108 cons_init
f0105864 g       .stab	00000000 __STAB_END__
f0105865 g       .stabstr	00000000 __STABSTR_BEGIN__
f0101720 g     F .text	00000151 .hidden __umoddi3
f01004db g     F .text	0000001c serial_intr
f01015f0 g     F .text	00000122 .hidden __udivdi3
f010067c g     F .text	0000000a iscons
f0101505 g     F .text	000000de strtol
f010127b g     F .text	00000021 strnlen
f01012bc g     F .text	00000022 strcat
f0112944 g     O .bss	00000004 panicstr
f0112940 g       .bss	00000000 end
f010013d g     F .text	0000003a _warn
f01013c5 g     F .text	0000001c strfind
f0101871 g       .text	00000000 etext
0010000c g       .text	00000000 _start
f010130b g     F .text	0000003b strlcpy
f010136c g     F .text	00000038 strncmp
f01012de g     F .text	0000002d strncpy
f01014a9 g     F .text	00000039 memcmp
f010065b g     F .text	00000010 cputchar
f01013e1 g     F .text	0000004d memset
f010066b g     F .text	00000011 getchar
f0100c9f g     F .text	0000001d printfmt
f010711f g       .stabstr	00000000 __STABSTR_END__
f0101346 g     F .text	00000026 strcmp
f0100a02 g     F .text	000001d1 debuginfo_eip
f01008d2 g     F .text	00000026 vcprintf
f0110000 g       .data	00000000 bootstacktop
f0110000 g     O .data	00001000 entry_pgdir
f0108000 g       .data	00000000 bootstack
f0101f94 g       .stab	00000000 __STAB_BEGIN__
f0101263 g     F .text	00000018 strlen
f01013a4 g     F .text	00000021 strchr
f01006be g     F .text	000000b0 mon_kerninfo
f0100778 g     F .text	00000147 monitor
f01014e2 g     F .text	00000023 memfind
f0100686 g     F .text	00000038 mon_help
```
Program Header 部分, vdddr 指 virtual address, paddr 指 physical address, memsz/filesz 指 the size of the loaded area.  

`boot/main.c` 中, 每一个程序头的 `ph->p_pa` 域都包含了段的目标物理地址(the segment's destination physical address).  
BIOS 从内存 0x7c00 开始加载引导扇区. 于是就有了 Exercise 5 的内容.  

ELF 头中还有一个非常重要的域叫 `e_entry`, 这个我们也在 `bootmain()` 里见过. 这个域持有这个程序的入口链接地址(the link address of the entry point), 也就是程序 text 段的内存地址.  
```
ivan@ubuntu:~/6.828/jos$ objdump -f obj/kern/kernel

obj/kern/kernel:     file format elf32-i386
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0010000c
```
接着是完成 Exercise 6 的内容.  

## Part 3: The Kernel


# Exercises
## Exercise 1
> **Exercise 1.** Familiarize yourself with the assembly language materials available on [the 6.828 reference page](https://pdos.csail.mit.edu/6.828/2018/reference.html). You don't have to read them now, but you'll almost certainly want to refer to some of this material when reading and writing x86 assembly.
>  
> We do recommend reading the section "The Syntax" in [Brennan's Guide to Inline Assembly](http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html). It gives a good (and quite brief) description of the AT&T assembly syntax we'll be using with the GNU assembler in JOS.

正文部分说过了, 有专门开一个文章写汇编书. 本身汇编也是专业课吧, 所以花了点时间, 统计了下有 70k 字.  
另外一个 [*Brennan's Guide to Inline Assembly*](http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html) 是一个讲 C Inline 汇编的文章. 没有看了, 见叔的文章[$^2$](#ref2).  

## Exercise 2
> **Exercise 2.** Use GDB's si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing. You might want to look at [Phil Storrs I/O Ports Description](http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm), as well as other materials on the [6.828 reference materials page](https://pdos.csail.mit.edu/6.828/2018/reference.html). No need to figure out all the details - just the general idea of what the BIOS is doing first.

使用 `si` 指令逐步调试然后猜作用.  
```asm
[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b
[f000:e05b]    0xfe05b:	cmpl   $0x0,%cs:0x6c48      # cs == 0xf000
[f000:e062]    0xfe062:	jne    0xfd2e1
[f000:e066]    0xfe066:	xor    %dx,%dx              # dx = 0
[f000:e068]    0xfe068:	mov    %dx,%ss              # ss = dx = 0
[f000:e06a]    0xfe06a:	mov    $0x7000,%esp         # esp = 0x7000
[f000:e070]    0xfe070:	mov    $0xf3691,%edx        # edx = 0xf3691
[f000:e076]    0xfe076:	jmp    0xfd165
[f000:d165]    0xfd165:	mov    %eax,%ecx            # ecx = eax
[f000:d168]    0xfd168:	cli                         # 
[f000:d169]    0xfd169:	cld                         # DF = 0, 增方向
```
> CLI：Clear Interupt, 禁止中断发生. STL：Set Interupt, 允许中断发生. CLI和STI是用来屏蔽中断和恢复中断用的, 如设置栈基址SS和偏移地址SP时, 需要CLI, 因为如果这两条指令被分开了, 那么很有可能SS被修改了, 但由于中断, 而代码跳去其它地方执行了, SP还没来得及修改, 就有可能出错.   
> CLD: Clear Director. STD：Set Director. 在字行块传送时使用的, 它们决定了块传送的方向. CLD使得传送方向从低地址到高地址, 而STD则相反. [$^3$](#ref3)  

```asm
[f000:d16a]    0xfd16a:	mov    $0x8f,%eax           # eax = 0x8f
[f000:d170]    0xfd170:	out    %al,$0x70            # 将 al 的数据导出到 0x70 端口
[f000:d172]    0xfd172:	in     $0x71,%al            # 将 0x71 端口的数据导入到 al
```
out 和 in 指令用于操作 IO 端口. 
> CPU与外部设备通讯时, 通常是通过访问, 修改设备控制器中的寄存器来实现的. 那么这些位于设备控制器当中的寄存器也叫做IO端口. 为了方便管理, 80x86CPU采用IO端口单独编址的方式, 即所有设备的端口都被命名到一个IO端口地址空间中. 这个空间是独立于内存地址空间的. 所以必须采用和访问内存的指令不一样的指令来访问端口.   
> 0x70端口和0x71端口是用于控制系统中一个叫做CMOS的设备, 这个设备是一个低功耗的存储设备, 它可以用于在计算机关闭时存储一些信息, 它是由独立的电池供电的.   
> 这个CMOS中可以控制跟PC相关的多个功能, 其中最重要的就是时钟设备（Real Time Clock）的 , 它还可以控制是否响应不可屏蔽中断NMI(Non-Maskable Interrupt).   
> 操作CMOS存储器中的内容需要两个端口, 一个是0x70另一个就是0x71. 其中0x70可以叫做索引寄存器, 这个8位寄存器的最高位是不可屏蔽中断(NMI)使能位. 如果你把这个位置1, 则NMI不会被响应. 低7位用于指定CMOS存储器中的存储单元地址, 所以如果你想访问第1号存储单元, 并且在访问时, 我要使能NMI, 那么你就应该向端口0x70里面送入0b10000001 = 0x81. [$^4$](#ref4)  

这里 mov 0x8f 到 eax 中, 然后将值导入 0x70 端口, 是为了能通过 0x71 端口访问存储单元 0xf 的值(`in $0x71,%al`), 并且关闭 NMI 中断. 但是 al 的值并没有被利用. **所以认为这三行是用来关闭 NMI 中断的.**  
```asm
[f000:d174]    0xfd174:	in     $0x92,%al            # 将 0x92 端口的数据导入到 al
[f000:d176]    0xfd176:	or     $0x2,%al             # 将 al 的(右数)第 1 位(bit1)置为 1
[f000:d178]    0xfd178:	out    %al,$0x92            # 将 al 导回去
```
这三行的作用就是将 0x92 端口的 bit1 修改为 1.  
0x92 控制的是 PS/2 系统控制接口 A[$^5$](#ref5), 而 bit 1= 1 indicates A20 active, 即 bit1 是 A20 位, 即第 21 个地址线被使能. **A20 地址线被激活时, 系统工作在保护模式.** 但是 boot loader 程序中计算机仍需要工作在实模式下. 所以这里应该只是测试可用内存空间.[$^6$](#ref6)  
```asm
[f000:d17a]    0xfd17a:	lidtw  %cs:0x6c38           # 将从地址 0x6c38 起始的后面 6 个字节数据读入 IDTR 中
```
> lidt指令：加载中断向量表寄存器(IDTR). 这个指令会把从地址0xf6ab8起始的后面6个字节的数据读入到中断向量表寄存器(IDTR)中. 中断是操作系统中非常重要的一部分, 有了中断操作系统才能真正实现进程. 每一种中断都有自己对应的中断处理程序, 那么这个中断的处理程序的首地址就叫做这个中断的中断向量. 中断向量表自然是存放所有中断向量的表了. [$^4$](#ref4)

```asm
[f000:d180]    0xfd180:	lgdtw  %cs:0x6bf4           # 
```
把从 0xf6bf4 为起始地址处的6个字节的值加载到全局描述符表格寄存器(GDTR)中. GDTR 将在 boot loader 中介绍.  
```asm
[f000:d186]    0xfd186:	mov    %cr0,%eax
[f000:d189]    0xfd189:	or     $0x1,%eax
[f000:d18d]    0xfd18d:	mov    %eax,%cr0            # cr0 |= 0x1
```
将控制寄存器的 bit0 置 1. 计算机包含四个控制寄存器 CR0~CR3, CR0 是 PE 位(启动保护位), 置 1 表示开启保护模式.  
```asm
[f000:d190]    0xfd190:	ljmpl  $0x8,$0xfd198
The target architecture is assumed to be i386
=> 0xfd198:	mov    $0x10,%eax                       # eax = 0x10
=> 0xfd19d:	mov    %eax,%ds                         # ds = eax
=> 0xfd19f:	mov    %eax,%es                         # es = eax
=> 0xfd1a1:	mov    %eax,%ss                         # ss = eax
=> 0xfd1a3:	mov    %eax,%fs                         # fs = eax
=> 0xfd1a5:	mov    %eax,%gs                         # gs = eax
=> 0xfd1a7:	mov    %ecx,%eax                        # eax = ecx
=> 0xfd1a9:	jmp    *%edx
=> 0xf3691:	push   %ebx                             # 熟悉的子程序调用...
...
```
上面这些寄存器设置是按规定来的. 刚刚加载完 GDTR 必须要重新加载所有段寄存器的值[$^7$](#ref7), 而 CS 段寄存器必须通过长跳转指令(`ljmp`), 这样相当于使 GDTR 生效[$^4$](#ref4).  

> F Segment (FS). Pointer to more extra data ('F' comes after 'E').  
> G Segment (GS). Pointer to still more extra data ('G' comes after 'F').[$^2$](#ref2)

## Exercise 3
> **Exercise 3.** Take a look at the [lab tools guide](https://pdos.csail.mit.edu/6.828/2018/labguide.html), especially the section on GDB commands. Even if you're familiar with GDB, this includes some esoteric GDB commands that are useful for OS work.
> 
> Set a breakpoint at address 0x7c00, which is where the boot sector will be loaded. Continue execution until that breakpoint. Trace through the code in `boot/boot.S`, using the source code and the disassembly file `obj/boot/boot.asm` to keep track of where you are. Also use the `x/i` command in GDB to disassemble sequences of instructions in the boot loader, and compare the original boot loader source code with both the disassembly in `obj/boot/boot.asm` and GDB.
> 
> Trace into `bootmain()` in `boot/main.c`, and then into `readsect()`. Identify the exact assembly instructions that correspond to each of the statements in `readsect()`. Trace through the rest of `readsect()` and back out into `bootmain()`, and identify the begin and end of the `for` loop that reads the remaining sectors of the kernel from the disk. Find out what code will run when the loop is finished, set a breakpoint there, and continue to that breakpoint. Then step through the remainder of the boot loader.


用 GDB 在 0x7c00 处打个断点, 这个地址也就是引导扇区的起始地址. 使用 `x/i` 来查看 boot loader 内的指令, 然后与 `obj/bool/boot.asm` 的反汇编代码进行比较.  
在 `boot.S` 部分, 设置 CR0 时, GDB 调试出的代码, 和反汇编代码都不太相同:  
GDB:  
```asm
   0x7c1a:	mov    $0xdf,%al
   0x7c1c:	out    %al,$0x60
   0x7c1e:	lgdtw  0x7c64
   0x7c23:	mov    %cr0,%eax
```
boot.asm:  
```asm
  movl    %cr0, %eax
    7c24:       20 c0                   and    %al,%al
  orl     $CR0_PE_ON, %eax
    7c26:       66 83 c8 01             or     $0x1,%ax
  movl    %eax, %cr0
    7c2a:       0f 22 c0                mov    %eax,%cr0
```
原因未知, 但是功能实现了, 便无论代码了.  
接着到 0x7d15<bootmain> 的位置:  
```asm
# void bootmain(void) {
    0x7d15:	push   %ebp
    0x7d16:	mov    %esp,%ebp
    0x7d18:	push   %esi
    0x7d19:	push   %ebx

    # 三个参数入栈
    0x7d1a:	push   $0x0                  # offset = 0
    0x7d1c:	push   $0x1000               # count  = SECTSIZE * 8 = 0x200 << 3
    0x7d21:	push   $0x10000              # pa     = 0x10000
    # 调用 readseg
    0x7d26:	call   0x7cdc
        # void readseg(uint32_t pa, uint32_t count, uint32_t offset) {
        0x7cdc:	push   %ebp
        0x7cdd:	mov    %esp,%ebp
        0x7cdf:	push   %edi
        0x7ce0:	push   %esi

        0x7ce1:	mov    0x10(%ebp),%edi   # edi = offset
        0x7ce4:	push   %ebx              # 保存 ebx, 下下行用到了这个寄存器
        0x7ce5:	mov    0xc(%ebp),%esi    # esi = count
        0x7ce8:	mov    0x8(%ebp),%ebx    # ebx = pa

        0x7ceb:	shr    $0x9,%edi         # offset = (offset / SECTSIZE)
        0x7cee:	add    %ebx,%esi         # count += pa, esi(count) --> esi(end_pa)
        0x7cf0:	inc    %edi              # offset += 1   // 跟上上一行共同构成 offset = (offset / SECTSIZE) + 1;
        0x7cf1:	and    $0xfffffe00,%ebx  # pa &= ~(SECTSIZE - 1);

        # while (pa < end_pa)
        0x7cf7:	cmp    %esi,%ebx
        0x7cf9:	jae    0x7d0d

        # 参数入栈准备调用函数
        0x7cfb:	push   %edi              # offset
        0x7cfc:	push   %ebx              # pa

        0x7cfd:	inc    %edi              # offset++;
        0x7cfe:	add    $0x200,%ebx       # pa += SECTSIZE;
        # 调用 readsect
        0x7d04:	call   0x7c7c
            # void readsect(void *dst, uint32_t offset) {
            0x7c7c:	push   %ebp
            0x7c7d:	mov    %esp,%ebp

            0x7c7f:	push   %edi                          # 保存 edi
            0x7c80:	mov    0xc(%ebp),%ecx                # ecx = offset
            # 调用 waitdisk
            0x7c83:	call   0x7c6a
                # void waitdisk(void) {
                0x7c6a:	push   %ebp
                0x7c6b:	mov    $0x1f7,%edx           # edx = 0x1f7
                0x7c70:	mov    %esp,%ebp

                0x7c72:	in     (%dx),%al             # al = inb(0x1F7)
                0x7c73:	and    $0xffffffc0,%eax      # eax & 0xC0
                # while ((inb(0x1F7) & 0xC0) != 0x40)
                0x7c76:	cmp    $0x40,%al
                0x7c78:	jne    0x7c72

                0x7c7a:	pop    %ebp
                0x7c7b:	ret
                # }

            # outb(0x1F2, 1);
            0x7c88:	mov    $0x1f2,%edx               # edx = 0x1f2
            0x7c8d:	mov    $0x1,%al                  # al = 1
            0x7c8f:	out    %al,(%dx)
            # outb(0x1F3, offset);
            0x7c90:	mov    $0x1f3,%edx               # edx = 0x1f3
            0x7c95:	mov    %cl,%al                   # al = cl; ecx == offset
            0x7c97:	out    %al,(%dx)
            # outb(0x1F4, offset >> 8);
            0x7c98:	mov    %ecx,%eax                 # eax = ecx = offset
            0x7c9a:	mov    $0x1f4,%edx               # edx = 0x1f4
            0x7c9f:	shr    $0x8,%eax                 # eax >>= 8
            0x7ca2:	out    %al,(%dx)
            # outb(0x1F5, offset >> 16);
            0x7ca3:	mov    %ecx,%eax                 # eax = ecx = offset 
            0x7ca5:	mov    $0x1f5,%edx               # edx = 0x1f5
            0x7caa:	shr    $0x10,%eax                # eax >>= 16
            0x7cad:	out    %al,(%dx)
            # outb(0x1F6, (offset >> 24) | 0xE0);
            0x7cae:	mov    %ecx,%eax                 # eax = ecx = offset
            0x7cb0:	mov    $0x1f6,%edx               # edx = 0x1f6
            0x7cb5:	shr    $0x18,%eax                # edx >>= 24
            0x7cb8:	or     $0xffffffe0,%eax          # edx |= 0xe0
            0x7cbb:	out    %al,(%dx)
            # outb(0x1F7, 0x20)
            0x7cbc:	mov    $0x1f7,%edx               # edx = 0x1f7
            0x7cc1:	mov    $0x20,%al                 # al = 0x20
            0x7cc3:	out    %al,(%dx)

            # 调用 waitdisk (略)
            0x7cc4:	call   0x7c6a

            # insl(0x1F0, dst, SECTSIZE/4);
            0x7cc9:	mov    0x8(%ebp),%edi            # dst
            0x7ccc:	mov    $0x80,%ecx                # SECTSIZE/4
            0x7cd1:	mov    $0x1f0,%edx               # 0x1F0
            0x7cd6:	cld                              # DF = 0
            0x7cd7:	repnz insl (%dx),%es:(%edi)

            0x7cd9:	pop    %edi
            0x7cda:	pop    %ebp
            0x7cdb:	ret
            # }

        0x7d0d:	lea    -0xc(%ebp),%esp               # 复原 esp
        0x7d10:	pop    %ebx
        0x7d11:	pop    %esi
        0x7d12:	pop    %edi
        0x7d13:	pop    %ebp
        0x7d14:	ret
        # }

    # 参数退栈
    0x7d2b:	add    $0xc,%esp
    # if (ELFHDR->e_magic != ELF_MAGIC) {
    0x7d2e:	cmpl   $0x464c457f,0x10000
    # goto bad;
    0x7d38:	jne    0x7d71
    # }

        # bad: {
        # outw(0x8A00, 0x8A00);
        0x7d71:	mov    $0x8a00,%edx
        0x7d76:	mov    $0xffff8a00,%eax
        0x7d7b:	out    %ax,(%dx)
        # outw(0x8A00, 0x8E00);
        0x7d7d:	mov    $0xffff8e00,%eax
        0x7d82:	out    %ax,(%dx)
        # while (1);
        0x7d84:	jmp    0x7d84
        # }

    # ebx == ph, esi == eph
    # ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);
    0x7d3a:	mov    0x1001c,%eax                      # eax = 0x1001c == ELFHDR->e_phoff
    0x7d3f:	movzwl 0x1002c,%esi                      # esi = 0x1002c
    0x7d46:	lea    0x10000(%eax),%ebx                # ph = ebx = eax + ELFHDR
    # eph = ph + ELFHDR->e_phnum;
    0x7d4c:	shl    $0x5,%esi                         # esi <<= 5; esi == ELFHDR->e_phnum
    0x7d4f:	add    %ebx,%esi                         # eph = esi = ELFHDR->e_phnum + ph

    # for (; ph < eph; ph++) {
    0x7d51:	cmp    %esi,%ebx
    0x7d53:	jae    0x7d6b

    # 参数入栈
    0x7d55:	pushl  0x4(%ebx)                         # ph->p_offset
    0x7d58:	pushl  0x14(%ebx)                        # ph->p_memsz
    0x7d5b:	add    $0x20,%ebx                        # ph++
    0x7d5e:	pushl  -0x14(%ebx)                       # ph->p_pa
    0x7d61:	call   0x7cdc                            # 调用 readseg (略)
    0x7d66:	add    $0xc,%esp                         # 参数出栈
    0x7d69:	jmp    0x7d51
    # }

    # ((void (*)(void)) (ELFHDR->e_entry))();
    0x7d6b:	call   *0x10018
# } // bootmain quit
```  
就没比较了, 花了好长时间把代码读了, 并且和 C 源代码做了对应.  

## Exercise 4
> **Exercise 4.** Read about programming with pointers in C. The best reference for the C language is *The C Programming Language* by Brian Kernighan and Dennis Ritchie (known as 'K&R'). We recommend that students purchase this book (here is an [Amazon Link](http://www.amazon.com/C-Programming-Language-2nd/dp/0131103628/sr=8-1/qid=1157812738/ref=pd_bbs_1/104-1502762-1803102?ie=UTF8&s=books)) or find one of [MIT's 7 copies](http://library.mit.edu/F/AI9Y4SJ2L5ELEE2TAQUAAR44XV5RTTQHE47P9MKP5GQDLR9A8X-10422?func=item-global&doc_library=MIT01&doc_number=000355242&year=&volume=&sub_library=).
> 
> Read 5.1 (Pointers and Addresses) through 5.5 (Character Pointers and Functions) in K&R. Then download the code for [pointers.c](https://pdos.csail.mit.edu/6.828/2018/labs/lab1/pointers.c), run it, and make sure you understand where all of the printed values come from. In particular, make sure you understand where the pointer addresses in printed lines 1 and 6 come from, how all the values in printed lines 2 through 4 get there, and why the values printed in line 5 are seemingly corrupted.
> 
> There are other references on pointers in C (e.g., [A tutorial by Ted Jensen](https://pdos.csail.mit.edu/6.828/2018/readings/pointers.pdf) that cites K&R heavily), though not as strongly recommended.
> 
> Warning: Unless you are already thoroughly versed in C, do not skip or even skim this reading exercise. If you do not really understand pointers in C, you will suffer untold pain and misery in subsequent labs, and then eventually come to understand them the hard way. Trust us; you don't want to find out what "the hard way" is.


被安利了两本 classic, 一本是 K&R, 另外一本是 *Pointers in C*. 他让我们去读关于 C 指针的内容. 过于基础我们跳过.  
最后还有个警告, 说的是即使你是老司机还是不推荐跳过或者略读推荐内容, 因为老司机在后面的 lab 中也很容易翻车. 我们直接无视它.  
pointer.c 的代码:  
```c
#include <stdio.h>
#include <stdlib.h>

void
f(void)
{
    int a[4];
    int *b = malloc(16);
    int *c;
    int i;

    printf("1: a = %p, b = %p, c = %p\n", a, b, c);

    c = a;
    for (i = 0; i < 4; i++)
        a[i] = 100 + i;
    c[0] = 200;
    printf("2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	      a[0], a[1], a[2], a[3]);

    c[1] = 300;
    *(c + 2) = 301;
    3[c] = 302;
    printf("3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	      a[0], a[1], a[2], a[3]);

    c = c + 1;
    *c = 400;
    printf("4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	      a[0], a[1], a[2], a[3]);

    c = (int *) ((char *) c + 1);
    *c = 500;
    printf("5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	      a[0], a[1], a[2], a[3]);

    b = (int *) a + 1;
    c = (int *) ((char *) a + 1);
    printf("6: a = %p, b = %p, c = %p\n", a, b, c);
}

int
main(int ac, char **av)
{
    f();
    return 0;
}
```

## Exercise 5
> **Exercise 5.** Trace through the first few instructions of the boot loader again and identify the first instruction that would "break" or otherwise do the wrong thing if you were to get the boot loader's link address wrong. Then change the link address in boot/Makefrag to something wrong, run` make clean`, recompile the lab with `make`, and trace into the boot loader again to see what happens. Don't forget to change the link address back and `make clean` again afterward!

这个习题我有留意 myk 和叔的文章, 孟佬把改成 0x8c00 了, 叔改成了 0x6c00, 我就试试 0x1c00 会怎么样吧.   
修改 `boot/Makefrag` 里的地址信息(随便改, 反正整个项目有版本控制程序托管), 将 0x7c00 改成 0x1c00, 先执行一次 `make clean`, 再执行一次 `make`, 看效果.  
make 的信息还是跟之前一样. 但是这里要插入一小段, `ld: warning: section '.bss' type changed to PROGBITS` 这一行根据叔的文章, 在 0x7c00 的情况下他是没有出现的, 而我是两次都有出现, 引用一下他的文章:  
> 如果.bss是NOBITS的，那么链接器会在输出的文件里告诉操作系统当这个程序被加载的时候，根据提供的信息，将某一块内存给分配出来，并置0，但是如果是PROGBITS的话，就是告诉系统从文件里取出一块已经被置0的数据段存入内存中，所以区别就在NOBITS的文件中，.bbs数据段是不占用空间的，但是PROGBITS的数据段是占用空间的。虽然最后对运行的程序没什么影响，最大的影响是可执行文件多了一块被置零的数据段，需要占用更多的空间。[$^2$](#ref2)

然后, 先用 `objdump` 检查一下地址:   
```
ivan@ubuntu:~/6.828/jos$ objdump -h obj/boot/boot.out 

obj/boot/boot.out:     file format elf32-i386

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000186  00001c00  00001c00  00000074  2**2
                  CONTENTS, ALLOC, LOAD, CODE
  1 .eh_frame     000000a8  00001d88  00001d88  000001fc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .stab         00000720  00000000  00000000  000002a4  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      0000088f  00000000  00000000  000009c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .comment      00000035  00000000  00000000  00001253  2**0
                  CONTENTS, READONLY
```
可以看到 `.text` 的 VMA 和 LMA 确实是到 0x1c00 了.  
接着我使用 gdb 在 0x1c00 处断点是没法跟踪的. 直接运行进行测试:  
```
ivan@ubuntu:~/6.828/jos$ make qemu-nox
sed "s/localhost:1234/localhost:26000/" < .gdbinit.tmpl > .gdbinit
***
*** Use Ctrl-a x to exit qemu
***
qemu-system-i386 -nographic -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log 
main-loop: WARNING: I/O thread spun for 1000 iterations
```
然后就在这里卡住了. 转到虚拟机中的 Ubuntu 桌面环境执行 `make qemu`, 会发现 qemu 窗口在不停闪烁, 隐约看到有 `Booting from hard disk` 的字样. 
接着我们测试 0x7c00 之后的地址, 我选择了 0xac00. 情况完全相同. 
使用 gdb 调试, 将断点打在 0x7c00 的位置:  
```
(gdb) b *0x7c00
Breakpoint 1 at 0x7c00
(gdb) c
Continuing.
[   0:7c00] => 0x7c00:	cli    

Breakpoint 1, 0x00007c00 in ?? ()
(gdb) x/50
   0x7c01:	cld    
   0x7c02:	xor    %ax,%ax
   0x7c04:	mov    %ax,%ds
   0x7c06:	mov    %ax,%es
   0x7c08:	mov    %ax,%ss
   0x7c0a:	in     $0x64,%al
   0x7c0c:	test   $0x2,%al
   0x7c0e:	jne    0x7c0a
   0x7c10:	mov    $0xd1,%al
   0x7c12:	out    %al,$0x64
   0x7c14:	in     $0x64,%al
   0x7c16:	test   $0x2,%al
   0x7c18:	jne    0x7c14
   0x7c1a:	mov    $0xdf,%al
   0x7c1c:	out    %al,$0x60
   0x7c1e:	lgdtw  -0x539c
   0x7c23:	mov    %cr0,%eax
   0x7c26:	or     $0x1,%eax
   0x7c2a:	mov    %eax,%cr0
   0x7c2d:	ljmp   $0x8,$0xac32
   0x7c32:	mov    $0xd88e0010,%eax
   0x7c38:	mov    %ax,%es
   0x7c3a:	mov    %ax,%fs
   0x7c3c:	mov    %ax,%gs
   0x7c3e:	mov    %ax,%ss
   0x7c40:	mov    $0xac00,%sp
   0x7c43:	add    %al,(%bx,%si)
   0x7c45:	call   0x7d13
   0x7c48:	add    %al,(%bx,%si)
   0x7c4a:	jmp    0x7c4a
   0x7c4c:	add    %al,(%bx,%si)
   0x7c4e:	add    %al,(%bx,%si)
   0x7c50:	add    %al,(%bx,%si)
   0x7c52:	add    %al,(%bx,%si)
   0x7c54:	(bad)  
   0x7c55:	incw   (%bx,%si)
   0x7c57:	add    %al,(%bx,%si)
   0x7c59:	lcall  $0xffff,$0xcf
   0x7c5e:	add    %al,(%bx,%si)
   0x7c60:	add    %dl,0xcf(%bp,%si)
   0x7c64:	pop    %ss
   0x7c65:	add    %cl,-0x54(%si)
   0x7c68:	add    %al,(%bx,%si)
   0x7c6a:	push   %bp
   0x7c6b:	mov    $0x1f7,%dx
   0x7c6e:	add    %al,(%bx,%si)
   0x7c70:	mov    %sp,%bp
   0x7c72:	in     (%dx),%al
   0x7c73:	and    $0xffc0,%ax
   0x7c76:	cmp    $0x40,%al
```

作为参考我打印了原来情形的后文 50 个指令:  
```asm
(gdb) x/50
   0x7c01:	cld    
   0x7c02:	xor    %ax,%ax
   0x7c04:	mov    %ax,%ds
   0x7c06:	mov    %ax,%es
   0x7c08:	mov    %ax,%ss
   0x7c0a:	in     $0x64,%al
   0x7c0c:	test   $0x2,%al
   0x7c0e:	jne    0x7c0a
   0x7c10:	mov    $0xd1,%al
   0x7c12:	out    %al,$0x64
   0x7c14:	in     $0x64,%al
   0x7c16:	test   $0x2,%al
   0x7c18:	jne    0x7c14
   0x7c1a:	mov    $0xdf,%al
   0x7c1c:	out    %al,$0x60
   0x7c1e:	lgdtw  0x7c64
   0x7c23:	mov    %cr0,%eax
   0x7c26:	or     $0x1,%eax
   0x7c2a:	mov    %eax,%cr0
   0x7c2d:	ljmp   $0x8,$0x7c32
   0x7c32:	mov    $0xd88e0010,%eax
   0x7c38:	mov    %ax,%es
   0x7c3a:	mov    %ax,%fs
   0x7c3c:	mov    %ax,%gs
   0x7c3e:	mov    %ax,%ss
   0x7c40:	mov    $0x7c00,%sp
   0x7c43:	add    %al,(%bx,%si)
   0x7c45:	call   0x7d13
   0x7c48:	add    %al,(%bx,%si)
   0x7c4a:	jmp    0x7c4a
   0x7c4c:	add    %al,(%bx,%si)
   0x7c4e:	add    %al,(%bx,%si)
   0x7c50:	add    %al,(%bx,%si)
   0x7c52:	add    %al,(%bx,%si)
   0x7c54:	(bad)  
   0x7c55:	incw   (%bx,%si)
   0x7c57:	add    %al,(%bx,%si)
   0x7c59:	lcall  $0xffff,$0xcf
   0x7c5e:	add    %al,(%bx,%si)
   0x7c60:	add    %dl,0xcf(%bp,%si)
   0x7c64:	pop    %ss
   0x7c65:	add    %cl,0x7c(%si)
   0x7c68:	add    %al,(%bx,%si)
   0x7c6a:	push   %bp
   0x7c6b:	mov    $0x1f7,%dx
   0x7c6e:	add    %al,(%bx,%si)
   0x7c70:	mov    %sp,%bp
   0x7c72:	in     (%dx),%al
   0x7c73:	and    $0xffc0,%ax
   0x7c76:	cmp    $0x40,%al
```
因为一时间手头没有什么比较文本的工具, 就直接用 `git diff` 了:  
```
diff --git a/ex5 b/ex5
index 3955d53..76c3fd6 100644
--- a/ex5
+++ b/ex5
@@ -14,17 +14,17 @@
    0x7c18:     jne    0x7c14
    0x7c1a:     mov    $0xdf,%al
    0x7c1c:     out    %al,$0x60
-   0x7c1e:     lgdtw  0x7c64
+   0x7c1e:     lgdtw  -0x539c
    0x7c23:     mov    %cr0,%eax
    0x7c26:     or     $0x1,%eax
    0x7c2a:     mov    %eax,%cr0
-   0x7c2d:     ljmp   $0x8,$0x7c32
+   0x7c2d:     ljmp   $0x8,$0xac32
    0x7c32:     mov    $0xd88e0010,%eax
    0x7c38:     mov    %ax,%es
    0x7c3a:     mov    %ax,%fs
    0x7c3c:     mov    %ax,%gs
    0x7c3e:     mov    %ax,%ss
-   0x7c40:     mov    $0x7c00,%sp
+   0x7c40:     mov    $0xac00,%sp
    0x7c43:     add    %al,(%bx,%si)
    0x7c45:     call   0x7d13
    0x7c48:     add    %al,(%bx,%si)
@@ -40,7 +40,7 @@
    0x7c5e:     add    %al,(%bx,%si)
    0x7c60:     add    %dl,0xcf(%bp,%si)
    0x7c64:     pop    %ss
-   0x7c65:     add    %cl,0x7c(%si)
+   0x7c65:     add    %cl,-0x54(%si)
    0x7c68:     add    %al,(%bx,%si)
    0x7c6a:     push   %bp
    0x7c6b:     mov    $0x1f7,%dx
```
出了一些蛮大的问题, GDTR 被扔了一个负地址进去, 这显然是不合法的; 长跳转的位置随着 0x7c00 被修改成 0xac00 也随之变动了, 原本应该直接跳转到下一个指令的, 现在不知道跳到哪里去了, 所以后面就不用再看了.  
我在修改时候建了个分支, 现在切回 `lab1` 分支, 然后把改动的删除.  

## Exercise 6
> **Exercise 6.** We can examine memory using GDB's `x` command. The [GDB manual](https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html) has full details, but for now, it is enough to know that the command `x/Nx ADDR` prints N words of memory at ADDR. (Note that both '`x`'s in the command are lowercase.) Warning: The size of a word is not a universal standard. In GNU assembly, a word is two bytes (the 'w' in xorw, which stands for word, means 2 bytes).
> 
> Reset the machine (exit QEMU/GDB and start them again). Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)


在刚进入 boot loader 的时候(将断点打在 0x7c00), 打印出的数据全是 0.  
```
(gdb) x/8x 0x00100000
0x100000:	0x00000000	0x00000000	0x00000000	0x00000000
0x100010:	0x00000000	0x00000000	0x00000000	0x00000000
```  
接着我们将断点打在调用 `e_entry` 的位置:  
```
(gdb) b *0x7d6b
Breakpoint 1 at 0x7d6b
(gdb) c
Continuing.
The target architecture is assumed to be i386
=> 0x7d6b:	call   *0x10018

Breakpoint 1, 0x00007d6b in ?? ()
(gdb) x/8x 0x0010000
0x10000:	0x464c457f	0x00010101	0x00000000	0x00000000
0x10010:	0x00030002	0x00000001	0x0010000c	0x00000034
```
可以看到 0x0010000 中已经有数据了.  
这里程序执行到了 `call *0x10018` 的位置, 再执行一次 `si`, 程序跳转到了 0x10000c 的位置, 查看了一下 0x10018 内存中的一个字, 发现里面确实存储的是 0x0010000c, 这就不是问题了.  

这里我们可以断言, 0x0010000c 是 kernel 的入口代码地址. 两次打印结果不同是因为 kernel 在之后被加载进了内存中.  

参考叔的文章, 这里我们还发现了一个问题:  
```
(gdb) x/10i 0x100000
   0x100000:	add    0x1bad(%eax),%dh
   0x100006:	add    %al,(%eax)
   0x100008:	decb   0x52(%edi)
   0x10000b:	in     $0x66,%al
   0x10000d:	movl   $0xb81234,0x472
   0x100017:	add    %dl,(%ecx)
   0x100019:	add    %cl,(%edi)
   0x10001b:	and    %al,%bl
   0x10001d:	mov    %cr0,%eax
   0x100020:	or     $0x80010001,%eax
```
这里我们发现, 显示 0x100000 后面的指令, 并没有出现 0x10000c 地址处的指令, 这显然是有问题的. 我们换一个方式:  
```
(gdb) x/5i 0x10000c
=> 0x10000c:	movw   $0x1234,0x472
   0x100015:	mov    $0x110000,%eax
   0x10001a:	mov    %eax,%cr3
   0x10001d:	mov    %cr0,%eax
   0x100020:	or     $0x80010001,%eax
```
接着我们去关注一下 kernel 编译的汇编文件 `obj/kern/kernel.asm`:  
```asm
f0100000:       02 b0 ad 1b 00 00       add    0x1bad(%eax),%dh
f0100006:       00 00                   add    %al,(%eax)
f0100008:       fe 4f 52                decb   0x52(%edi)
f010000b:       e4                      .byte 0xe4

f010000c <entry>:
f010000c:       66 c7 05 72 04 00 00    movw   $0x1234,0x472
f0100013:       34 12
        # sufficient until we set up our real page table in mem_init
        # in lab 2.

        # Load the physical address of entry_pgdir into cr3.  entry_pgdir
        # is defined in entrypgdir.c.
        movl    $(RELOC(entry_pgdir)), %eax
f0100015:       b8 00 00 11 00          mov    $0x110000,%eax
        movl    %eax, %cr3
f010001a:       0f 22 d8                mov    %eax,%cr3
        # Turn on paging.
        movl    %cr0, %eax
f010001d:       0f 20 c0                mov    %cr0,%eax
        orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
```
0xf010000b 处的 `e4` 编码被 gdb 错误的解释了. 所以才会遇到刚才的问题.  


# 引用
1. [https://pdos.csail.mit.edu/6.828/2018/labs/lab1/](https://pdos.csail.mit.edu/6.828/2018/labs/lab1/)  
2. <span id="ref2">[https://github.com/Spdwal/LearningLanuages/blob/master/OperatingSystem/6.828/lab1.md](https://github.com/Spdwal/LearningLanuages/blob/master/OperatingSystem/6.828/lab1.md)</span>  
3. <span id="ref3">[https://blog.csdn.net/qq_32473685/article/details/93626548#1%20%C2%A0%E4%B8%BB%E8%A6%81%E9%98%85%E8%AF%BB%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%B5%84%E6%96%99%E3%80%82](https://blog.csdn.net/qq_32473685/article/details/93626548#1%20%C2%A0%E4%B8%BB%E8%A6%81%E9%98%85%E8%AF%BB%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%B5%84%E6%96%99%E3%80%82)</span>  
4. <span id="ref4">[https://www.cnblogs.com/fatsheep9146/p/5078179.html](https://www.cnblogs.com/fatsheep9146/p/5078179.html)</span>  
5. <span id="ref5">[http://bochs.sourceforge.net/techspec/PORTS.LST](http://bochs.sourceforge.net/techspec/PORTS.LST)</span>  
6. <span id="ref6">[http://kernelx.weebly.com/a20-address-line.html](http://kernelx.weebly.com/a20-address-line.html )</span>
7. <span id="ref7">[https://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table](https://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table)</span>
8. [https://zhuanlan.zhihu.com/p/36926462](https://zhuanlan.zhihu.com/p/36926462)
9. [https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf](https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf)
10. [http://en.wikipedia.org/wiki/Executable_and_Linkable_Format](http://en.wikipedia.org/wiki/Executable_and_Linkable_Format)