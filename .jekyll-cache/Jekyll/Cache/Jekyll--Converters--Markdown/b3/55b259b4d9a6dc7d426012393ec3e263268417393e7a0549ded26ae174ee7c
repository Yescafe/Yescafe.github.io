I"?<p>为了区分STL和pb_ds库中的容器和函数, 该篇博文中所有出现的类 / 函数 / 方法等, 均将在前面加上名称空间名(namespace).</p>
<h3 id="一-绪言">一. 绪言</h3>
<p>众所周知, C++有STL(Standard Template Library). STL中包含了非常多的容器(Containers)和容器适配器(Container Adaptors), 这里稍微地不完全地列举一下(包括他们的中文名):</p>

<p><strong>Containers 容器:</strong></p>

<p><em>Sequence containers 线性容器:</em></p>
<ul>
  <li>vector - 向量</li>
  <li>array  - 数组</li>
  <li>list   - 序列</li>
  <li>deque  - 双端队列</li>
</ul>

<p><em>Associative containers 关联容器:</em></p>
<ul>
  <li>set      - 集合</li>
  <li>map      - 映射</li>
  <li>multiset - 多集合</li>
  <li>multimap - 多映射</li>
</ul>

<p><strong>Container Adaptors 容器适配器:</strong></p>
<ul>
  <li>stack          - 栈</li>
  <li>queue          - 队列</li>
  <li>priority_queue - 优先队列(堆)</li>
</ul>

<p>这些DS(Data Structures), 不管是打ACM, 还是平时编码, 出现的频率都是非常高的.<br />
原因还是要归功与C++的模板及元能力, 给容器提供了泛型(genericity). STL中对各种DS的封装, 给我们省去了很多构建基础DS的时间.</p>

<p>但是, 实际在使用STL时, 会感觉到很多功能受限. 比如STL中提供的堆容器, 只是最最基础的堆,</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Defined in header &lt;queue&gt;</span>
<span class="k">template</span><span class="o">&lt;</span>
    <span class="k">class</span> <span class="nc">T</span><span class="p">,</span>
    <span class="k">class</span> <span class="nc">Container</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;,</span>
    <span class="k">class</span> <span class="nc">Compare</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="o">::</span><span class="n">value_type</span><span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="k">class</span> <span class="nc">priority_queue</span><span class="p">;</span>
</code></pre></div></div>
<p>并没有任何可扩展性. 比如在某些情况下需要高效地合并两个堆的时候, 使用STL提供的std::priority_queue::push方法</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// std::priority_queue::push</span>
<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">);</span>
<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="p">);</span> <span class="c1">// (since C++11)</span>
</code></pre></div></div>
<p>将显得非常的低效(这种也被叫做”暴力合并”). 对这方面比较了解的同学一定知道, 我这里是在点名可并堆.</p>

<p>另外, 比如STL中没有给我们提供树结构. 虽然set和map的内部是由红黑树(Red-black Tree)实现的, 但是毕竟这两个容器的使用范围比红黑树要狭窄, 我们想要的, 还是有一个最基本的红黑树, 给我们提供快速搜索的功能. 说到搜索, 另外地想到了哈希表(Hash Table), 虽然STL(C++11)给我们提供了hash,</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Defined in header &lt;functional&gt;</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Key</span> <span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">hash</span><span class="p">;</span>  <span class="c1">// (Since C++11)</span>
</code></pre></div></div>
<p>但是其实并没有提供一个现成的哈希表供我们使用, 有些情况下使用起来并不方便.</p>

<h3 id="二-库简述">二. 库简述</h3>
<p>gcc给我们提供的pb_ds(Policy-based Data Structures)库被藏在了标准库中比较深的地方,</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;ext/pb_ds/assoc_container.hpp&gt;
#include &lt;ext/pb_ds/priority_queue.hpp&gt;
#include &lt;ext/pb_ds/exception.hpp&gt;
#include &lt;ext/pb_ds/hash_policy.hpp&gt;
#include &lt;ext/pb_ds/list_update_policy.hpp&gt;
#include &lt;ext/pb_ds/tree_policy.hpp&gt;
#include &lt;ext/pb_ds/trie_policy.hpp&gt;
</span></code></pre></div></div>
<p>这其中包含的一些看似方便使用的DS, 如priority_queue(优先队列/堆), hash(哈希), tree(树), trie(字典树), 并不属于C++标准模板库的范畴, 并且他们也是gcc特有的. <br />
因为不属于STL, 使用他们的方法也就不能通过cppreference很轻松地查找到. 前两天我也花了一点时间使用国内外的搜索引擎去搜索有关pb_ds库的内容, 但比较直观的教程实在是屈指可数. 于是最终我选择了直接阅读g++文档和pb_ds的源码, 来直接了解pb_ds的内容. btw, g++也官方给出了一些简单的教程, 这里也将参考.</p>

<h3 id="三-容器简述">三. 容器简述</h3>
<p>我将在这一部分给出pb_ds库中的一些类的简单描述, 稍后会在各个类独立的文章中给出细节说明和Sample.</p>
<ul>
  <li><strong>Priority Queue 优先队列 / 堆</strong><br />
这个类在STL里是有的, 下面是STL里优先队列的声明,
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Defined in header &lt;queue&gt;</span>
<span class="k">template</span><span class="o">&lt;</span>
  <span class="k">class</span> <span class="nc">T</span><span class="p">,</span>
  <span class="k">class</span> <span class="nc">Container</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;,</span>
  <span class="k">class</span> <span class="nc">Compare</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="o">::</span><span class="n">value_type</span><span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="k">class</span> <span class="nc">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>观察一下它的三个模板参数:<br />
第一个是元素类型 (value_type);<br />
第二个优先队列作为容器适配器需要一个基础容器提供支持, 对于优先队列, 这个被维护的容器可以是vector / deque / list, 有关为什么是他们, 是跟他们的迭代器类型有关的, 这里不做具体讨论了;<br />
第三个是用于排序的比较函数.<br />
作为一个最基础的堆, 要求其实是各种操作的复杂度都能相对稳定. 但是对于一些特殊的要求, 比如前文提到的可并堆, 最基础的堆即使是优化到最极限, 也赶不上可并堆的合并效率.<br />
这时, pb_ds库给我们提供了一种解法, 我们先来看一下pb_ds库中的优先队列的声明,</p>
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Defined in header &lt;ext/pb_ds/priority_queue.hpp&gt;</span>
<span class="k">template</span><span class="o">&lt;</span>
  <span class="k">typename</span> <span class="nc">_Tv</span><span class="p">,</span>
  <span class="k">typename</span> <span class="nc">Cmp_Fn</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="n">_Tv</span><span class="p">&gt;,</span>
  <span class="k">typename</span> <span class="n">Tag</span> <span class="o">=</span> <span class="n">pairing_heap_tag</span><span class="p">,</span>
  <span class="k">typename</span> <span class="n">_Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="k">class</span> <span class="nc">__gnu_pbds</span><span class="o">::</span><span class="n">priority_queue</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">detail</span><span class="o">::</span><span class="n">container_base_dispatch</span><span class="o">&lt;</span><span class="n">_Tv</span><span class="p">,</span> <span class="n">Cmp_Fn</span><span class="p">,</span> <span class="n">_Alloc</span><span class="p">,</span> <span class="n">Tag</span><span class="o">&gt;::</span><span class="n">type</span>
</code></pre></div>    </div>
    <p>相对于STL中的优先队列, 很容易发现两点: 第一, 这是一个真正意义上的堆, 而不是通过维护其他容器实现的; 第二, 模板参数里有个Tag, 默认值是pairing_heap_tag, 配对堆, 这意味着我们可能可以通过修改tag的值, 来微调堆的实现.</p>
  </li>
  <li><strong>Tree 树</strong><br />
树这种结构没什么好说的, 而且STL里没有, 直接看声明:
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Defined in header &lt;ext/pb_ds/assoc_container.hpp&gt;</span>
<span class="k">template</span><span class="o">&lt;</span>
  <span class="k">typename</span> <span class="nc">Key</span><span class="p">,</span>
  <span class="k">typename</span> <span class="nc">Mapped</span><span class="p">,</span>
  <span class="k">typename</span> <span class="nc">Cmp_Fn</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
  <span class="k">typename</span> <span class="n">Tag</span> <span class="o">=</span> <span class="n">rb_tree_tag</span><span class="p">,</span>
  <span class="k">template</span><span class="o">&lt;</span>
      <span class="k">typename</span> <span class="nc">Node_CItr</span><span class="p">,</span>
      <span class="k">typename</span> <span class="nc">Node_Itr</span><span class="p">,</span>
      <span class="k">typename</span> <span class="nc">Cmp_Fn_</span><span class="p">,</span>
      <span class="k">typename</span> <span class="nc">_Alloc_</span>
  <span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Node_Update</span> <span class="o">=</span> <span class="n">null_node_update</span><span class="p">,</span>
  <span class="k">typename</span> <span class="n">_Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="k">class</span> <span class="nc">tree</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">PB_DS_TREE_BASE</span>
</code></pre></div>    </div>
    <p>模板参数有点过于复杂了, 但是其实这里面更多的参数都是有默认值的, 不需要我们去修改. 其他的模板参数将在正式文章里介绍, 这里先关注一下和上面的堆一样的Tag, 这里的默认值是rb_tree_tag, 也就是红黑树, 那个搜索起来比哈希表还要快的红黑树.</p>
  </li>
  <li><strong>Trie 字典树</strong><br />
这种结构我完全不了解, 具体的内容将在正式文章中补上. 先看声明:
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Defined in header &lt;ext/pb_ds/assoc_container.hpp&gt;</span>
<span class="k">template</span><span class="o">&lt;</span>
  <span class="k">typename</span> <span class="nc">Key</span><span class="p">,</span>
  <span class="k">typename</span> <span class="nc">Mapped</span><span class="p">,</span>
  <span class="k">typename</span> <span class="nc">_ATraits</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">detail</span><span class="o">::</span><span class="n">default_trie_access_traits</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;</span><span class="o">::</span><span class="n">type</span><span class="p">,</span>
  <span class="k">typename</span> <span class="n">Tag</span> <span class="o">=</span> <span class="n">pat_trie_tag</span><span class="p">,</span>
  <span class="k">template</span><span class="o">&lt;</span>
      <span class="k">typename</span> <span class="nc">Node_CItr</span><span class="p">,</span>
      <span class="k">typename</span> <span class="nc">Node_Itr</span><span class="p">,</span>
      <span class="k">typename</span> <span class="nc">_ATraits_</span><span class="p">,</span>
      <span class="k">typename</span> <span class="nc">_Alloc_</span>
  <span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Node_Update</span> <span class="o">=</span> <span class="n">null_node_update</span><span class="p">,</span>
  <span class="k">typename</span> <span class="n">_Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="k">class</span> <span class="nc">trie</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">PB_DS_TRIE_BASE</span>
</code></pre></div>    </div>
    <p>这个模板参数比上面的树还要复杂, 而且好像还有个traits (- -b). 这个对我来说比较复杂的, 且完全陌生的数据结构, 将放在最后讨论.</p>
  </li>
  <li><strong>Hash Table 哈希表</strong>
pb_ds库给我们提供了好几个哈希表, 每一个具体什么样的, 我还没有开始研究. 这里先给出basic_hash_table声明:
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Defined in header &lt;ext/pb_ds/assoc_container.hpp&gt;</span>
<span class="k">template</span><span class="o">&lt;</span>
  <span class="k">typename</span> <span class="nc">Key</span><span class="p">,</span>
  <span class="k">typename</span> <span class="nc">Mapped</span><span class="p">,</span>
  <span class="k">typename</span> <span class="nc">Hash_Fn</span><span class="p">,</span>
  <span class="k">typename</span> <span class="nc">Eq_Fn</span><span class="p">,</span>
  <span class="k">typename</span> <span class="nc">Resize_Policy</span><span class="p">,</span>
  <span class="kt">bool</span> <span class="n">Store_Hash</span><span class="p">,</span>
  <span class="k">typename</span> <span class="nc">Tag</span><span class="p">,</span>
  <span class="k">typename</span> <span class="nc">Policy_Tl</span><span class="p">,</span>
  <span class="k">typename</span> <span class="nc">_Alloc</span>
<span class="p">&gt;</span> <span class="k">class</span> <span class="nc">basic_hash_table</span>
<span class="o">:</span> <span class="k">public</span> <span class="n">PB_DS_HASH_BASE</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>更多的内容将放在正式文章中.</p>

<h3 id="四-policy和tag相关">四. Policy和Tag相关</h3>
<p>暂不明晰. 待补充.</p>

<h3 id="代码来源">代码来源</h3>
<p>上文中出现的代码, 均来自cppreference, libstdc++-api和pb_ds库的源码, 本文仅对原代码的格式进行了细微的调整, 使其更方便阅读.</p>
:ET