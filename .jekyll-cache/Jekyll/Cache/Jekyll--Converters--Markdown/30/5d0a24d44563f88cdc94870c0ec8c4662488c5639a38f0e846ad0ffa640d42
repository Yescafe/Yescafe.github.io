I"<p>今天乍一看哎哟woc, 我做的这个题目单是Top 100 liked 而不是什么Top 100 Classic或者easiest, 算了, 既然上了车车门焊死了, 也就不要下车了.<br />
地址: https://leetcode.com/problemset/top-100-liked-questions/</p>

<h2 id="3-longest-substring-without-repeating-characters">3. Longest Substring Without Repeating Characters</h2>
<p><strong>Difficulty: medium</strong></p>

<p>Given a string, find the length of the longest substring without repeating characters.</p>

<p><strong>Example 1:</strong></p>

<p>Input: “abcabcbb”
Output: 3 
Explanation: The answer is “abc”, with the length of 3.</p>

<p><strong>Example 2:</strong></p>

<blockquote>
  <p>Input: “bbbbb”
Output: 1
Explanation: The answer is “b”, with the length of 1.</p>
</blockquote>

<p><strong>Example 3:</strong></p>

<blockquote>
  <p>Input: “pwwkew”<br />
Output: 3<br />
Explanation: The answer is “wke”, with the length of 3. <br />
                          Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
</blockquote>

<p>乍一眼一看, 这不就是搞两根”筷子”夹着substrings, 然后慢慢夹出一个最大的.  <br />
我们开一个二维数组(momery[x][y])来存x和y之间的所有子字符串有没有重复. 用1表示可以使用, 0表示不能使用, 2表示还没有计算. <br />
但是而后想一想, emmm, 这样做不就是暴力嘛! 你不超时谁超时…</p>

<p>换一种思路, 字符总数量也就200+个嘛, 干脆直接使用记忆化, 还是用两筷子.</p>

<p><strong>Only Version</strong></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">(</span><span class="mi">260</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]])</span> <span class="p">{</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="o">++</span><span class="n">l</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="o">++</span><span class="n">r</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>好了, 说实话这思路是讨论区剽的. 菜是原罪.</p>

<p>解释一下思路, 通过上面的方法, 可以把所有无重复字母的<strong>局部最大</strong>子串的长度全部统计出来. 分别取最大就好了.</p>

<p>其他方法不考虑了. 这就是最好的方法.</p>

<p><strong>Rate:</strong><br />
Runtime: 32 ms, faster than 34.30% of C++ online submissions for Longest Substring Without Repeating Characters.<br />
Memory Usage: 10.4 MB, less than 70.91% of C++ online submissions for Longest Substring Without Repeating Characters.</p>
:ET